<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ã‚†ã‚‹ã‚¹ã‚±</title>
  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="ã‚†ã‚‹ã‚¹ã‚±">
  <link rel="apple-touch-icon" href="icon-192.svg">
  <meta name="description" content="ã‚†ã‚‹ãäºˆå®šã‚’ç®¡ç†ã™ã‚‹ã‚¢ãƒ—ãƒª">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      min-height: 100dvh;
    }
    .app {
      max-width: 600px;
      margin: 0 auto;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      background: #fff;
    }
    header {
      background: #4a90d9;
      color: white;
      padding: 12px 16px;
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 { font-size: 18px; font-weight: 600; }
    .reset-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.4);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }
    .reset-btn:hover { background: rgba(255,255,255,0.3); }
    .header-spacer { width: 60px; }
    .main-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 16px;
      line-height: 1.4;
      font-size: 15px;
    }
    .message.user {
      align-self: flex-end;
      background: #4a90d9;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .message.system {
      align-self: flex-start;
      background: #e8e8e8;
      color: #333;
      border-bottom-left-radius: 4px;
    }
    .message.confirm {
      align-self: flex-start;
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffc107;
      border-bottom-left-radius: 4px;
    }
    .confirm-buttons {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    .confirm-buttons button {
      flex: 1;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-ok { background: #28a745; color: white; }
    .btn-cancel { background: #dc3545; color: white; }
    .btn-skip { background: #6c757d; color: white; }
    .btn-add { background: #007bff; color: white; }
    .input-form {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      background: #fff;
      border-top: 1px solid #e0e0e0;
    }
    .input-form input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 24px;
      font-size: 16px;
      outline: none;
    }
    .input-form input:focus { border-color: #4a90d9; }
    .input-form input:disabled { background: #f5f5f5; }
    .input-form button {
      padding: 12px 20px;
      background: #4a90d9;
      color: white;
      border: none;
      border-radius: 24px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
    }
    .input-form button:disabled { background: #ccc; }
    .schedule-text {
      white-space: pre-wrap;
      font-family: inherit;
      line-height: 1.6;
    }
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .input-form {
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="header-spacer"></div>
      <h1>äºˆå®šç®¡ç†</h1>
      <button class="reset-btn" id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
    </header>
    <div class="main-container">
      <div class="chat-section">
        <div class="messages" id="messages"></div>
        <form class="input-form" id="inputForm">
          <input type="text" id="inputField" placeholder="äºˆå®šã‚’å…¥åŠ›..." autocomplete="off">
          <button type="submit">é€ä¿¡</button>
        </form>
      </div>
    </div>
  </div>

  <script>
    // çŠ¶æ…‹ç®¡ç†
    let schedules = JSON.parse(localStorage.getItem('schedules') || '[]');
    let pendingAction = null; // { type: 'add'|'modify'|'delete', ... }

    // DOMè¦ç´ 
    const messagesEl = document.getElementById('messages');
    const inputForm = document.getElementById('inputForm');
    const inputField = document.getElementById('inputField');

    // ============================================
    // æ—¥ä»˜ãƒ»æ™‚é–“ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆéƒ¨å“ã¨ã—ã¦ä½¿ç”¨ï¼‰
    // ============================================
    function parseDateFromText(input) {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      let date = null;
      let consumed = '';

      const weekdayMap = { 'æ—¥': 0, 'æœˆ': 1, 'ç«': 2, 'æ°´': 3, 'æœ¨': 4, 'é‡‘': 5, 'åœŸ': 6 };

      // ä»Šæœˆæœ« / æ¥æœˆæœ« / å†æ¥æœˆæœ«
      const monthEndMatch = input.match(/(ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)æœ«/);
      if (monthEndMatch && !date) {
        date = new Date(today);
        if (monthEndMatch[1] === 'æ¥æœˆ') date.setMonth(date.getMonth() + 1);
        else if (monthEndMatch[1] === 'å†æ¥æœˆ') date.setMonth(date.getMonth() + 2);
        date = new Date(date.getFullYear(), date.getMonth() + 1, 0);
        consumed = monthEndMatch[0];
      }

      // ä»Šæœˆé ­ / æ¥æœˆé ­
      const monthStartMatch = input.match(/(ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)(é ­|åˆã‚?|ã‚ãŸã¾|ã¯ã˜ã‚)/);
      if (monthStartMatch && !date) {
        date = new Date(today);
        if (monthStartMatch[1] === 'ä»Šæœˆ' && today.getDate() > 5) date.setMonth(date.getMonth() + 1);
        else if (monthStartMatch[1] === 'æ¥æœˆ') date.setMonth(date.getMonth() + 1);
        else if (monthStartMatch[1] === 'å†æ¥æœˆ') date.setMonth(date.getMonth() + 2);
        date.setDate(1);
        consumed = monthStartMatch[0];
      }

      // æ¥é€±/ä»Šé€±/å†æ¥é€± + æ›œæ—¥
      const weekMatch = input.match(/(æ¥é€±|ä»Šé€±|å†æ¥é€±)ã®?([æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ])æ›œ?æ—¥?/);
      if (weekMatch && !date) {
        const weekOffset = weekMatch[1] === 'æ¥é€±' ? 1 : weekMatch[1] === 'å†æ¥é€±' ? 2 : 0;
        const targetDay = weekdayMap[weekMatch[2]];
        date = new Date(today);
        let daysToAdd = targetDay - date.getDay();
        if (daysToAdd <= 0 && weekOffset === 0) daysToAdd += 7;
        date.setDate(date.getDate() + daysToAdd + weekOffset * 7);
        consumed = weekMatch[0];
      }

      // ä»Šåº¦ã® + æ›œæ—¥
      const nextWeekdayMatch = input.match(/ä»Šåº¦ã®?([æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ])æ›œ?æ—¥?/);
      if (nextWeekdayMatch && !date) {
        const targetDay = weekdayMap[nextWeekdayMatch[1]];
        date = new Date(today);
        let daysToAdd = targetDay - date.getDay();
        if (daysToAdd <= 0) daysToAdd += 7;
        date.setDate(date.getDate() + daysToAdd);
        consumed = nextWeekdayMatch[0];
      }

      // æ˜æ—¥/æ˜å¾Œæ—¥/ã‚ã•ã£ã¦/ã—ã‚ã•ã£ã¦/ä»Šæ—¥
      const dayPatterns = [
        { regex: /ã—ã‚ã•ã£ã¦/, days: 3 },
        { regex: /(æ˜å¾Œæ—¥|ã‚ã•ã£ã¦)/, days: 2 },
        { regex: /æ˜æ—¥/, days: 1 },
        { regex: /ä»Šæ—¥/, days: 0 },
      ];
      for (const { regex, days } of dayPatterns) {
        const match = input.match(regex);
        if (match && !date) {
          date = new Date(today);
          date.setDate(date.getDate() + days);
          consumed = match[0];
          break;
        }
      }

      // Xæ—¥å¾Œ / Xé€±é–“å¾Œ
      const daysLaterMatch = input.match(/(\d+)æ—¥å¾Œ/);
      if (daysLaterMatch && !date) {
        date = new Date(today);
        date.setDate(date.getDate() + parseInt(daysLaterMatch[1]));
        consumed = daysLaterMatch[0];
      }

      const weeksLaterMatch = input.match(/(\d+)é€±é–“?å¾Œ/);
      if (weeksLaterMatch && !date) {
        date = new Date(today);
        date.setDate(date.getDate() + parseInt(weeksLaterMatch[1]) * 7);
        consumed = weeksLaterMatch[0];
      }

      // MæœˆDæ—¥ ã¾ãŸã¯ M/D
      const dateMatch = input.match(/(\d{1,2})[\/æœˆ](\d{1,2})æ—¥?/);
      if (dateMatch && !date) {
        date = new Date(today.getFullYear(), parseInt(dateMatch[1]) - 1, parseInt(dateMatch[2]));
        if (date < today) date.setFullYear(date.getFullYear() + 1);
        consumed = dateMatch[0];
      }

      return date ? { date, consumed } : null;
    }

    function parseTimeFromText(input) {
      let time = null;
      let consumed = '';

      const timePatterns = [
        { regex: /(\d{1,2})[æ™‚:](\d{2})åˆ†?/, handler: (m) => ({ h: parseInt(m[1]), m: parseInt(m[2]) }) },
        { regex: /(\d{1,2})æ™‚åŠ/, handler: (m) => ({ h: parseInt(m[1]), m: 30 }) },
        { regex: /(\d{1,2})æ™‚/, handler: (m) => ({ h: parseInt(m[1]), m: 0 }) },
        { regex: /(?<![\/\d])(\d{3,4})(?!\d|æ—¥|å¹´|æœˆ)/, handler: (m) => {
          const t = m[1].padStart(4, '0');
          const h = parseInt(t.slice(0, 2));
          const min = parseInt(t.slice(2));
          if (h >= 0 && h <= 23 && min >= 0 && min <= 59) return { h, m: min };
          return null;
        }},
      ];

      for (const { regex, handler } of timePatterns) {
        const match = input.match(regex);
        if (match) {
          const result = handler(match);
          if (result) {
            time = result;
            consumed = match[0];
            break;
          }
        }
      }

      if (!time) {
        const vagueTimePatterns = [
          { regex: /æ—©æœ/, hour: 6 },
          { regex: /æœ/, hour: 9 },
          { regex: /åˆå‰ä¸­?/, hour: 10 },
          { regex: /ãŠæ˜¼|æ˜¼/, hour: 12 },
          { regex: /åˆå¾Œ/, hour: 14 },
          { regex: /å¤•æ–¹|å¤•/, hour: 17 },
          { regex: /å¤œ|æ™©|å¤œé–“/, hour: 19 },
          { regex: /æ·±å¤œ/, hour: 23 },
        ];
        for (const { regex, hour } of vagueTimePatterns) {
          const match = input.match(regex);
          if (match) {
            time = { h: hour, m: 0 };
            consumed = match[0];
            break;
          }
        }
      }

      return time ? { time, consumed } : null;
    }

    function formatTime(time) {
      return time ? `${String(time.h).padStart(2, '0')}${String(time.m).padStart(2, '0')}` : null;
    }

    // ============================================
    // äºˆå®šè¿½åŠ ãƒ‘ãƒ¼ã‚µãƒ¼
    // ============================================
    function parseScheduleInput(input) {
      let title = input;

      const dateResult = parseDateFromText(input);
      if (!dateResult) return null;

      title = title.replace(dateResult.consumed, '').trim();

      const timeResult = parseTimeFromText(title);
      if (timeResult) {
        title = title.replace(timeResult.consumed, '').trim();
      }

      // ã‚¿ã‚¤ãƒˆãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      title = title
        .replace(/^[ã€,ã®ã«ã¯ã¸ã¨]\s*/, '')
        .replace(/\s*[ã€,ã®ã«ã¯ã¸ã¨]$/, '')
        .replace(/[ã€,]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      return {
        date: `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`,
        time: timeResult ? formatTime(timeResult.time) : null,
        title: title || 'äºˆå®š',
        fullDate: dateResult.date.toISOString(),
        isOther: false
      };
    }

    // ============================================
    // è¤‡æ•°äºˆå®šãƒ‘ãƒ¼ã‚µãƒ¼
    // ============================================
    // æ—¥ä»˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ­£è¦è¡¨ç¾ï¼ˆåˆ†å‰²ç”¨ï¼‰
    const datePatternRegex = /(\d{1,2}[\/æœˆ]\d{1,2}æ—¥?|(?:ä»Šæ—¥|æ˜æ—¥|æ˜å¾Œæ—¥|ã‚ã•ã£ã¦|ã—ã‚ã•ã£ã¦)|(?:æ¥é€±|ä»Šé€±|å†æ¥é€±)ã®?[æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ]æ›œ?æ—¥?|ä»Šåº¦ã®?[æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ]æ›œ?æ—¥?|\d+æ—¥å¾Œ|\d+é€±é–“?å¾Œ|(?:ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)(?:æœ«|é ­|åˆã‚?|ã‚ãŸã¾|ã¯ã˜ã‚))/g;

    function parseMultipleSchedules(input) {
      // æ—¥ä»˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä½ç½®ã‚’æ¤œå‡º
      const dateMatches = [...input.matchAll(datePatternRegex)].map(m => ({
        index: m.index,
        type: 'date',
        match: m[0]
      }));

      // æ™‚é–“ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç©ºç™½å¾Œã®4æ¡æ•°å­—ï¼‰ã‚’æ¤œå‡º
      const timeMatches = [];
      const timeRegex = /\s(\d{4})(?=\s|$|\D)/g;
      let match;
      while ((match = timeRegex.exec(input)) !== null) {
        const timeIndex = match.index + 1; // ç©ºç™½ã®æ¬¡ã®ä½ç½®
        const timeStr = match[1];
        // æœ‰åŠ¹ãªæ™‚é–“ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆ00-23æ™‚ã€00-59åˆ†ï¼‰
        const h = parseInt(timeStr.slice(0, 2));
        const m = parseInt(timeStr.slice(2));
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
          timeMatches.push({ index: timeIndex, type: 'time', match: timeStr });
        }
      }

      // æ—¥ä»˜ã®ç›´å¾Œã®æ™‚é–“ã¯é™¤å¤–ï¼ˆãã‚Œã¯æ—¥ä»˜ã«ä»˜éšã™ã‚‹æ™‚é–“ï¼‰
      const filteredTimeMatches = timeMatches.filter(tm => {
        return !dateMatches.some(dm => {
          const dmEnd = dm.index + dm.match.length;
          // æ—¥ä»˜ã®ç›´å¾Œï¼ˆç©ºç™½1ã¤åˆ†ï¼‰ãªã‚‰é™¤å¤–
          return tm.index > dmEnd && tm.index <= dmEnd + 2;
        });
      });

      // å…¨ã¦ã®åŒºåˆ‡ã‚Šã‚’ãƒãƒ¼ã‚¸ã—ã¦ã‚½ãƒ¼ãƒˆ
      const allMatches = [...dateMatches, ...filteredTimeMatches].sort((a, b) => a.index - b.index);

      if (allMatches.length <= 1) {
        return null;
      }

      // å„åŒºåˆ‡ã‚Šä½ç½®ã§å…¥åŠ›ã‚’åˆ†å‰²
      const segments = [];
      for (let i = 0; i < allMatches.length; i++) {
        const start = allMatches[i].index;
        const end = i < allMatches.length - 1 ? allMatches[i + 1].index : input.length;
        const segment = input.slice(start, end).trim();
        const hasDate = allMatches[i].type === 'date';
        if (segment) {
          segments.push({ text: segment, hasDate });
        }
      }

      // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆæ—¥ä»˜ãŒãªã„å ´åˆã¯ç›´å‰ã‹ã‚‰å¼•ãç¶™ãï¼‰
      const parsed = [];
      let lastDate = null;
      let lastFullDate = null;

      for (const seg of segments) {
        if (seg.hasDate) {
          const schedule = parseScheduleInput(seg.text);
          if (schedule) {
            parsed.push(schedule);
            lastDate = schedule.date;
            lastFullDate = schedule.fullDate;
          }
        } else if (lastDate) {
          // æ—¥ä»˜ãªã—ï¼ˆæ™‚é–“ã‹ã‚‰å§‹ã¾ã‚‹ï¼‰â†’ç›´å‰ã®æ—¥ä»˜ã‚’å¼•ãç¶™ã
          const timeResult = parseTimeFromText(seg.text);
          if (timeResult) {
            let title = seg.text.replace(timeResult.consumed, '').trim();
            title = title.replace(/^[ã€,ã®ã«ã¯ã¸ã¨]\s*/, '').replace(/\s*[ã€,ã®ã«ã¯ã¸ã¨]$/, '').trim();
            parsed.push({
              date: lastDate,
              time: formatTime(timeResult.time),
              title: title || 'äºˆå®š',
              fullDate: lastFullDate,
              isOther: false
            });
          }
        }
      }

      return parsed.length > 1 ? parsed : null;
    }

    // ============================================
    // äºˆå®šæ¤œç´¢
    // ============================================
    function findSchedule(dateStr, timeStr, keyword) {
      // æ—¥ä»˜ãƒ»æ™‚é–“ãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§äºˆå®šã‚’æ¤œç´¢
      const matches = schedules.filter(s => {
        const dateMatch = !dateStr || s.date === dateStr;
        const timeMatch = !timeStr || s.time === timeStr;
        const keywordMatch = !keyword || s.title.includes(keyword);
        return dateMatch && timeMatch && keywordMatch;
      });
      return matches;
    }

    // ============================================
    // å¤‰æ›´ãƒ»å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒ‘ãƒ¼ã‚µãƒ¼
    // ============================================
    function parseModificationRequest(input) {
      // å¤‰æ›´ãƒ‘ã‚¿ãƒ¼ãƒ³1: ã€Œã€œã‚’ã€œã«å¤‰æ›´ã€ã€Œã€œã‚’ã€œã«ã—ã¦ã€ã€Œã€œã‚’ã€œã«ä¿®æ­£ã€
      const modifyMatch1 = input.match(/(.+?)[ã‚’ã®](.+?)[ã«ã¸](å¤‰æ›´|ã—ã¦|ã™ã‚‹|ç§»å‹•|å¤‰ãˆã¦|ä¿®æ­£|ç›´ã—ã¦|è¨‚æ­£)/);
      if (modifyMatch1) {
        const target = modifyMatch1[1];
        const newValue = modifyMatch1[2];
        return parseTargetAndAction(target, 'modify', newValue);
      }

      // å¤‰æ›´ãƒ‘ã‚¿ãƒ¼ãƒ³2: ã€Œã€œ æ—¥ä»˜ æ™‚é–“ã«å¤‰æ›´ã€ã€Œã€œ æ™‚é–“ã«å¤‰æ›´ã€ã€Œã€œ æ—¥ä»˜ã«å¤‰æ›´ã€
      // åŒºåˆ‡ã‚Šæ–‡å­—: ã‚¹ãƒšãƒ¼ã‚¹ã€ã€Œã¯ã€ã€Œã‚’ã€ã€Œã€ã€
      const modifyEndMatch = input.match(/[ã«ã¸](å¤‰æ›´|å¤‰ãˆã¦|ç§»å‹•|ã—ã¦|ä¿®æ­£|ç›´ã—ã¦|è¨‚æ­£)$/);
      if (modifyEndMatch) {
        const beforeEnd = input.slice(0, modifyEndMatch.index).trim();

        // åŒºåˆ‡ã‚Šæ–‡å­—ãƒ‘ã‚¿ãƒ¼ãƒ³: ã‚¹ãƒšãƒ¼ã‚¹ã€ã¯ã€ã‚’ã€ã€
        const sep = '[\\sã€€ã¯ã‚’ã€]+';

        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: æ—¥ä»˜+æ™‚é–“ï¼ˆä¾‹: 2/15 18æ™‚ã€2/15 1800ï¼‰
        const dateTimeRegex = new RegExp(`^(.+?)${sep}(\\d{1,2}\\/\\d{1,2}[\\sã€€]+(?:\\d{1,2}æ™‚åŠ?|\\d{3,4}))$`);
        const dateTimeMatch = beforeEnd.match(dateTimeRegex);
        if (dateTimeMatch) {
          const targetPart = dateTimeMatch[1].trim();
          const newValuePart = dateTimeMatch[2].trim();
          return parseTargetAndAction(targetPart, 'modify', newValuePart);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: æ™‚é–“ã®ã¿ï¼ˆä¾‹: 18æ™‚ã€1800ï¼‰
        const timeRegex = new RegExp(`^(.+?)${sep}(\\d{1,2}æ™‚åŠ?|\\d{3,4})$`);
        const timeExprMatch = beforeEnd.match(timeRegex);
        if (timeExprMatch) {
          const targetPart = timeExprMatch[1].trim();
          const newValuePart = timeExprMatch[2].trim();
          const hasTime = parseTimeFromText(newValuePart);
          if (hasTime) {
            return parseTargetAndAction(targetPart, 'modify', newValuePart);
          }
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: æ—¥ä»˜ã®ã¿ï¼ˆä¾‹: 2/15ï¼‰
        const dateRegex = new RegExp(`^(.+?)${sep}(\\d{1,2}\\/\\d{1,2})$`);
        const dateExprMatch = beforeEnd.match(dateRegex);
        if (dateExprMatch) {
          const targetPart = dateExprMatch[1].trim();
          const newValuePart = dateExprMatch[2].trim();
          const hasDate = parseDateFromText(newValuePart);
          if (hasDate) {
            return parseTargetAndAction(targetPart, 'modify', newValuePart);
          }
        }
      }

      // å‰Šé™¤ãƒ‘ã‚¿ãƒ¼ãƒ³: æœ«å°¾ã«å‰Šé™¤ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆ
      const deleteKeywords = /(ã‚’?å‰Šé™¤|ã‚’?æ¶ˆã—ã¦|ã‚’?æ¶ˆã™|ãªããªã£ãŸ|ç„¡ããªã£ãŸ|ã‚­ãƒ£ãƒ³ã‚»ãƒ«|å–ã‚Š?æ¶ˆã—|ä¸­æ­¢|ã‚„ã‚(ãŸ|ã‚‹)?|é–“é•ã„(ã ã£ãŸ)?)$/;
      const deleteMatch = input.match(deleteKeywords);
      if (deleteMatch) {
        const target = input.replace(deleteKeywords, '').trim();
        return parseTargetAndAction(target, 'delete', null);
      }

      return null;
    }

    function parseTargetAndAction(targetStr, action, newValueStr) {
      // å¯¾è±¡ã‹ã‚‰æ—¥ä»˜ãƒ»æ™‚é–“ãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡º
      let targetDate = null;
      let targetTime = null;
      let keyword = targetStr;

      const dateResult = parseDateFromText(targetStr);
      if (dateResult) {
        targetDate = `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`;
        keyword = targetStr.replace(dateResult.consumed, '').trim();
      }

      // æ™‚é–“ã‚‚ãƒ‘ãƒ¼ã‚¹
      const timeResult = parseTimeFromText(keyword);
      if (timeResult) {
        targetTime = formatTime(timeResult.time);
        keyword = keyword.replace(timeResult.consumed, '').trim();
      }

      // ã€Œã®äºˆå®šã€ã€Œã®ã€ãªã©ã‚’é™¤å»
      keyword = keyword.replace(/ã®?äºˆå®š$/, '').replace(/^ã®/, '').trim();

      // å®Œå…¨ä¸€è‡´ã‚’å„ªå…ˆã—ã¦æ¤œç´¢
      let target = null;

      // 1. æ—¥ä»˜ãƒ»æ™‚é–“ãƒ»ã‚¿ã‚¤ãƒˆãƒ«å…¨ã¦æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€å®Œå…¨ä¸€è‡´ã‚’æ¢ã™
      if (targetDate && targetTime && keyword) {
        const exactMatch = schedules.find(s =>
          s.date === targetDate && s.time === targetTime && s.title === keyword
        );
        if (exactMatch) {
          target = exactMatch;
        }
      }

      // 2. å®Œå…¨ä¸€è‡´ãŒãªã‘ã‚Œã°éƒ¨åˆ†ä¸€è‡´ã§æ¤œç´¢
      if (!target) {
        const matches = findSchedule(targetDate, targetTime, keyword);

        if (matches.length === 0) {
          return { error: 'è©²å½“ã™ã‚‹äºˆå®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚' };
        }
        if (matches.length > 1) {
          return { error: `è¤‡æ•°ã®äºˆå®šãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ã‚‚ã†å°‘ã—å…·ä½“çš„ã«æŒ‡å®šã—ã¦ãã ã•ã„ã€‚\n${matches.map(s => `ãƒ»${s.date} ${s.time || ''} ${s.title}`).join('\n')}` };
        }
        target = matches[0];
      }

      if (action === 'delete') {
        return {
          type: 'delete',
          target
        };
      }

      // å¤‰æ›´ã®å ´åˆã€æ–°ã—ã„å€¤ã‚’ãƒ‘ãƒ¼ã‚¹
      if (action === 'modify') {
        let newDate = target.date;
        let newTime = target.time;
        let newFullDate = target.fullDate;

        const newDateResult = parseDateFromText(newValueStr);
        if (newDateResult) {
          newDate = `${newDateResult.date.getMonth() + 1}/${newDateResult.date.getDate()}`;
          newFullDate = newDateResult.date.toISOString();
        }

        const newTimeResult = parseTimeFromText(newValueStr);
        if (newTimeResult) {
          newTime = formatTime(newTimeResult.time);
        }

        return {
          type: 'modify',
          target,
          newSchedule: {
            ...target,
            date: newDate,
            time: newTime,
            fullDate: newFullDate
          }
        };
      }

      return null;
    }

    // ============================================
    // UIé–¢æ•°
    // ============================================
    function addMessage(type, text, buttonType = null) {
      const div = document.createElement('div');
      div.className = `message ${type}`;
      div.innerHTML = text;

      if (buttonType === 'confirm') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-ok" onclick="handleConfirm()">OK</button>
          <button class="btn-cancel" onclick="handleCancel()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        `;
        div.appendChild(btns);
      } else if (buttonType === 'duplicate') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-skip" onclick="handleDuplicateSkip()">åŒã˜äºˆå®šï¼ˆè¿½åŠ ã—ãªã„ï¼‰</button>
          <button class="btn-add" onclick="handleDuplicateAdd()">åˆ¥ã®äºˆå®šï¼ˆè¿½åŠ ã™ã‚‹ï¼‰</button>
        `;
        div.appendChild(btns);
      } else if (buttonType === 'warning') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-add" onclick="handleWarningAdd()">è¿½åŠ ã™ã‚‹</button>
          <button class="btn-cancel" onclick="handleWarningCancel()">ã‚„ã‚ã‚‹</button>
        `;
        div.appendChild(btns);
      } else if (buttonType === 'modify-warning') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-add" onclick="handleModifyWarningConfirm()">å¤‰æ›´ã™ã‚‹</button>
          <button class="btn-cancel" onclick="handleModifyWarningCancel()">ã‚„ã‚ã‚‹</button>
        `;
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'conflict-choice') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.style.flexWrap = 'wrap';
        buttonType.choices.forEach((choice, idx) => {
          const btn = document.createElement('button');
          btn.className = 'btn-add';
          btn.textContent = choice;
          btn.onclick = () => handleConflictChoice(idx);
          btns.appendChild(btn);
        });
        const bothBtn = document.createElement('button');
        bothBtn.className = 'btn-skip';
        bothBtn.textContent = 'ä¸¡æ–¹æ®‹ã™';
        bothBtn.onclick = () => handleConflictChoice(-1);
        btns.appendChild(bothBtn);
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'exact-duplicate') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        const mergeBtn = document.createElement('button');
        mergeBtn.className = 'btn-add';
        mergeBtn.textContent = '1ä»¶ã«ã¾ã¨ã‚ã‚‹';
        mergeBtn.onclick = () => handleConflictChoice(0);
        btns.appendChild(mergeBtn);
        const keepBtn = document.createElement('button');
        keepBtn.className = 'btn-skip';
        keepBtn.textContent = `${buttonType.count}ä»¶ã¨ã‚‚æ®‹ã™`;
        keepBtn.onclick = () => handleConflictChoice(-1);
        btns.appendChild(keepBtn);
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'double-booking') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.style.flexWrap = 'wrap';
        buttonType.schedules.forEach((s, idx) => {
          const btn = document.createElement('button');
          btn.className = 'btn-add';
          btn.textContent = `${s.title}ã‚’ä»–äººã®äºˆå®šã«ã™ã‚‹`;
          btn.onclick = () => handleDoubleBookingResolve(idx);
          btns.appendChild(btn);
        });
        const keepBtn = document.createElement('button');
        keepBtn.className = 'btn-skip';
        keepBtn.textContent = 'ã“ã®ã¾ã¾';
        keepBtn.onclick = () => handleDoubleBookingResolve(-1);
        btns.appendChild(keepBtn);
        div.appendChild(btns);
      }

      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆexcludeã§æŒ‡å®šã—ãŸäºˆå®šã¯é™¤å¤–ï¼‰
    function isDuplicate(schedule, exclude = null) {
      return schedules.some(s =>
        s !== exclude &&
        s.date === schedule.date &&
        s.time === schedule.time &&
        s.title === schedule.title
      );
    }

    // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆ2æ™‚é–“ä»¥å†…ã®äºˆå®šã‚’æ¤œå‡ºã€excludeã§æŒ‡å®šã—ãŸäºˆå®šã¯é™¤å¤–ï¼‰
    function findNearbySchedule(schedule, exclude = null) {
      if (!schedule.time || schedule.isOther) return null;

      const newTime = parseInt(schedule.time.slice(0, 2)) * 60 + parseInt(schedule.time.slice(2));

      for (const s of schedules) {
        // é™¤å¤–æŒ‡å®šã•ã‚ŒãŸäºˆå®šã¯ã‚¹ã‚­ãƒƒãƒ—
        if (s === exclude) continue;
        // åŒã˜æ—¥ã€æ™‚é–“ã‚ã‚Šã€è‡ªåˆ†ã®äºˆå®šï¼ˆisOther: falseï¼‰ã®ã¿
        if (s.date === schedule.date && s.time && !s.isOther) {
          const existingTime = parseInt(s.time.slice(0, 2)) * 60 + parseInt(s.time.slice(2));
          const diff = Math.abs(newTime - existingTime);
          if (diff > 0 && diff <= 120) { // 2æ™‚é–“ä»¥å†…ï¼ˆåŒä¸€æ™‚åˆ»ã¯é™¤ãï¼‰
            return s;
          }
        }
      }
      return null;
    }

    // åŒã˜æ—¥æ™‚ã«æ—¢å­˜ã®è‡ªåˆ†ã®äºˆå®šãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´æ™‚ç”¨ï¼‰
    function findSameTimeSchedules(schedule, exclude = null) {
      if (!schedule.time) return [];

      return schedules.filter(s =>
        s !== exclude &&
        !s.isOther &&
        s.date === schedule.date &&
        s.time === schedule.time
      );
    }

    // åŒã˜æ—¥æ™‚ã«è‡ªåˆ†ã®äºˆå®šãŒè¤‡æ•°ã‚ã‚‹å ´åˆã‚’æ¤œå‡ºï¼ˆèµ·å‹•æ™‚ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
    function findDoubleBookings() {
      const groups = {};
      schedules.forEach(s => {
        if (!s.isOther && s.time) {
          const key = `${s.date}_${s.time}`;
          if (!groups[key]) groups[key] = [];
          groups[key].push(s);
        }
      });

      // 2ä»¶ä»¥ä¸Šã‚ã‚‹æ—¥æ™‚ã‚’è¿”ã™
      const conflicts = [];
      Object.keys(groups).forEach(key => {
        if (groups[key].length >= 2) {
          conflicts.push({
            date: groups[key][0].date,
            time: groups[key][0].time,
            schedules: groups[key]
          });
        }
      });
      return conflicts;
    }

    // ä¸€æ‹¬å…¥åŠ›æ™‚ã®åŒä¸€æ—¥æ™‚ã®äºˆå®šã‚’æ¤œå‡ºï¼ˆå®Œå…¨é‡è¤‡ã¨ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ä¸¡æ–¹ï¼‰
    function findSameTimeConflicts(schedulesArray) {
      const groups = {};
      schedulesArray.forEach((s, idx) => {
        if (s.time && !s.isOther) {
          const key = `${s.date}_${s.time}`;
          if (!groups[key]) groups[key] = [];
          groups[key].push({ schedule: s, index: idx });
        }
      });

      const conflicts = [];
      Object.entries(groups).forEach(([key, items]) => {
        if (items.length <= 1) return;

        // åŒã˜ã‚¿ã‚¤ãƒˆãƒ«ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¤œå‡ºï¼ˆå®Œå…¨é‡è¤‡ï¼‰
        const titleGroups = {};
        items.forEach(item => {
          const title = item.schedule.title;
          if (!titleGroups[title]) titleGroups[title] = [];
          titleGroups[title].push(item);
        });

        // å®Œå…¨é‡è¤‡ï¼ˆåŒã˜ã‚¿ã‚¤ãƒˆãƒ«ãŒ2ä»¶ä»¥ä¸Šï¼‰
        Object.entries(titleGroups).forEach(([title, titleItems]) => {
          if (titleItems.length > 1) {
            conflicts.push({
              key,
              items: titleItems,
              type: 'exact-duplicate',
              title
            });
          }
        });

        // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ï¼ˆç•°ãªã‚‹ã‚¿ã‚¤ãƒˆãƒ«ãŒåŒã˜æ—¥æ™‚ï¼‰
        const uniqueTitles = Object.keys(titleGroups);
        if (uniqueTitles.length > 1) {
          // å„ã‚¿ã‚¤ãƒˆãƒ«ã‹ã‚‰1ä»¶ãšã¤å–å¾—
          const representativeItems = uniqueTitles.map(title => titleGroups[title][0]);
          conflicts.push({
            key,
            items: representativeItems,
            type: 'double-booking'
          });
        }
      });

      return conflicts;
    }

    function formatScheduleDisplay(s) {
      const timeStr = s.time ? ` ${s.time}` : '';
      if (s.isOther) {
        return `(${s.date}${timeStr} ${s.title})`;
      }
      return `${s.date}${timeStr} ${s.title}`;
    }

    function formatScheduleList() {
      if (schedules.length === 0) {
        return 'äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“';
      }

      const sorted = [...schedules].sort((a, b) => {
        const dateA = new Date(a.fullDate);
        const dateB = new Date(b.fullDate);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        return (a.time || '0000') > (b.time || '0000') ? 1 : -1;
      });

      const grouped = {};
      sorted.forEach(s => {
        if (!grouped[s.date]) grouped[s.date] = [];
        grouped[s.date].push(s);
      });

      let lines = ['äºˆå®šï¼'];
      Object.keys(grouped).forEach(date => {
        grouped[date].forEach((s, idx) => {
          const timeStr = s.time ? `${s.time} ` : '';
          const content = s.isOther ? `(${timeStr}${s.title})` : `${timeStr}${s.title}`;
          if (idx === 0) {
            lines.push(`${date} ${content}`);
          } else {
            lines.push(`      ${content}`);
          }
        });
      });

      return lines.join('\n');
    }

    function showScheduleList() {
      const text = formatScheduleList();
      addMessage('system', `<div class="schedule-text">${text}</div>`);
    }

    function setInputEnabled(enabled) {
      inputField.disabled = !enabled;
      document.querySelector('.input-form button').disabled = !enabled;
    }

    // ============================================
    // ç¢ºèªå‡¦ç†
    // ============================================
    function handleConfirm() {
      if (!pendingAction) return;

      if (pendingAction.type === 'add') {
        schedules.push(pendingAction.schedule);
      } else if (pendingAction.type === 'add-multiple') {
        schedules.push(...pendingAction.schedules);
      } else if (pendingAction.type === 'delete') {
        schedules = schedules.filter(s => s !== pendingAction.target);
      } else if (pendingAction.type === 'modify') {
        // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
        if (isDuplicate(pendingAction.newSchedule, pendingAction.target)) {
          addMessage('system', 'ã“ã®æ™‚é–“ã«æ—¢ã«åŒã˜äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚');
          pendingAction = null;
          setInputEnabled(true);
          return;
        }

        // åŒã˜æ—¥æ™‚ã«æ—¢å­˜ã®äºˆå®šãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
        const sameTimeSchedules = findSameTimeSchedules(pendingAction.newSchedule, pendingAction.target);
        if (sameTimeSchedules.length > 0) {
          const titles = sameTimeSchedules.map(s => s.title).join('ã€');
          const confirmText = `${formatScheduleDisplay(pendingAction.target)} â†’ ${formatScheduleDisplay(pendingAction.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ<br><span style="color:#e74c3c">âš  ${pendingAction.newSchedule.date} ${pendingAction.newSchedule.time} ã«æ—¢ã«äºˆå®šãŒã‚ã‚Šã¾ã™ï¼ˆ${titles}ï¼‰</span>`;
          addMessage('confirm', confirmText, 'modify-warning');
          return;
        }

        // 2æ™‚é–“ä»¥å†…ã®äºˆå®šãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
        const nearby = findNearbySchedule(pendingAction.newSchedule, pendingAction.target);
        if (nearby) {
          const confirmText = `${formatScheduleDisplay(pendingAction.target)} â†’ ${formatScheduleDisplay(pendingAction.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ<br><span style="color:#e74c3c">âš  ${formatScheduleDisplay(nearby)} ã®2æ™‚é–“ä»¥å†…ã«äºˆå®šãŒã‚ã‚Šã¾ã™</span>`;
          addMessage('confirm', confirmText, 'modify-warning');
          return;
        }

        const idx = schedules.indexOf(pendingAction.target);
        if (idx !== -1) {
          schedules[idx] = pendingAction.newSchedule;
        }
      }

      localStorage.setItem('schedules', JSON.stringify(schedules));
      showScheduleList();
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleCancel() {
      addMessage('system', 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleDuplicateSkip() {
      addMessage('system', 'è¿½åŠ ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleDuplicateAdd() {
      if (pendingAction && pendingAction.schedule) {
        schedules.push(pendingAction.schedule);
        localStorage.setItem('schedules', JSON.stringify(schedules));
        showScheduleList();
      }
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleWarningAdd() {
      if (pendingAction && pendingAction.schedule) {
        schedules.push(pendingAction.schedule);
        localStorage.setItem('schedules', JSON.stringify(schedules));
        showScheduleList();
      }
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleWarningCancel() {
      addMessage('system', 'è¿½åŠ ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleModifyWarningConfirm() {
      if (pendingAction && pendingAction.target && pendingAction.newSchedule) {
        const idx = schedules.indexOf(pendingAction.target);
        if (idx !== -1) {
          schedules[idx] = pendingAction.newSchedule;
        }
        localStorage.setItem('schedules', JSON.stringify(schedules));
        showScheduleList();
      }
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleModifyWarningCancel() {
      addMessage('system', 'å¤‰æ›´ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleDoubleBookingResolve(idx) {
      if (!pendingAction || pendingAction.type !== 'resolve-double-booking') return;

      if (idx >= 0) {
        // é¸æŠã•ã‚ŒãŸäºˆå®šã‚’ä»–äººã®äºˆå®šã«å¤‰æ›
        const targetSchedule = pendingAction.currentConflict.schedules[idx];
        const scheduleIdx = schedules.indexOf(targetSchedule);
        if (scheduleIdx !== -1) {
          schedules[scheduleIdx].isOther = true;
          localStorage.setItem('schedules', JSON.stringify(schedules));
          addMessage('system', `${targetSchedule.title} ã‚’ä»–äººã®äºˆå®šã«å¤‰æ›´ã—ã¾ã—ãŸã€‚`);
        }
      }

      // æ¬¡ã®ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ã‚’ãƒã‚§ãƒƒã‚¯
      pendingAction.conflictIndex++;
      if (pendingAction.conflictIndex < pendingAction.conflicts.length) {
        showNextDoubleBooking();
      } else {
        pendingAction = null;
        setInputEnabled(true);
        showScheduleList();
      }
    }

    function showNextDoubleBooking() {
      const conflict = pendingAction.conflicts[pendingAction.conflictIndex];
      pendingAction.currentConflict = conflict;
      const confirmText = `${conflict.date} ${conflict.time} ã«äºˆå®šãŒé‡ãªã£ã¦ã„ã¾ã™`;
      addMessage('confirm', confirmText, { type: 'double-booking', schedules: conflict.schedules });
    }

    function handleConflictChoice(choiceIdx) {
      if (!pendingAction || pendingAction.type !== 'resolve-conflict') return;

      const conflict = pendingAction.currentConflict;
      if (choiceIdx === -1) {
        // ä¸¡æ–¹æ®‹ã™ - ä½•ã‚‚ã—ãªã„
      } else {
        // é¸æŠã•ã‚ŒãŸã‚‚ã®ä»¥å¤–ã‚’é™¤å¤–
        const keepIndex = conflict.items[choiceIdx].index;
        conflict.items.forEach(item => {
          if (item.index !== keepIndex) {
            pendingAction.schedulesToRemove.add(item.index);
          }
        });
      }

      // æ¬¡ã®è¡çªã‚’ãƒã‚§ãƒƒã‚¯
      processNextConflict();
    }

    function processNextConflict() {
      const { allSchedules, conflicts, schedulesToRemove } = pendingAction;

      if (conflicts.length === 0) {
        // å…¨ã¦ã®è¡çªã‚’è§£æ±º â†’ æœ€çµ‚ç¢ºèª
        const finalSchedules = allSchedules.filter((_, idx) => !schedulesToRemove.has(idx));

        if (finalSchedules.length === 0) {
          addMessage('system', 'è¿½åŠ ã™ã‚‹äºˆå®šãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
          pendingAction = null;
          setInputEnabled(true);
          return;
        }

        const listText = finalSchedules.map(s => formatScheduleDisplay(s)).join('<br>');
        const confirmText = `${finalSchedules.length}ä»¶ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ<br>${listText}`;
        addMessage('confirm', confirmText, 'confirm');
        pendingAction = { type: 'add-multiple', schedules: finalSchedules };
        return;
      }

      // æ¬¡ã®è¡çªã‚’å‡¦ç†
      const nextConflict = conflicts.shift();
      // æ—¢ã«é™¤å¤–ã•ã‚ŒãŸã‚‚ã®ã‚’é™¤ã
      nextConflict.items = nextConflict.items.filter(item => !schedulesToRemove.has(item.index));

      if (nextConflict.items.length <= 1) {
        // è¡çªãŒè§£æ¶ˆã•ã‚ŒãŸ
        processNextConflict();
        return;
      }

      pendingAction.currentConflict = nextConflict;

      const [date, time] = nextConflict.key.split('_');

      if (nextConflict.type === 'exact-duplicate') {
        // å®Œå…¨é‡è¤‡
        const confirmText = `${date} ${time} ã«åŒã˜äºˆå®šãŒ${nextConflict.items.length}ä»¶ã‚ã‚Šã¾ã™ï¼š${nextConflict.title}`;
        addMessage('confirm', confirmText, { type: 'exact-duplicate', count: nextConflict.items.length });
      } else {
        // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°
        const choices = nextConflict.items.map(item => item.schedule.title);
        const confirmText = `${date} ${time} ã«${nextConflict.items.length}ä»¶ã®äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã‚’æ®‹ã—ã¾ã™ã‹ï¼Ÿ`;
        addMessage('confirm', confirmText, { type: 'conflict-choice', choices });
      }
    }

    // ============================================
    // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡
    // ============================================
    inputForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const input = inputField.value.trim();
      if (!input) return;

      addMessage('user', input);
      inputField.value = '';

      // äºˆå®šç¢ºèªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
      if (/äºˆå®š|ä¸€è¦§|ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«|ä»Šã©ã†ãªã£ã¦ã‚‹/.test(input) && !/ã‚’|ã«å¤‰æ›´|å‰Šé™¤|ã‚­ãƒ£ãƒ³ã‚»ãƒ«|ãªããªã£ãŸ|é–“é•ã„/.test(input)) {
        showScheduleList();
        return;
      }

      // ã¾ãšå¤‰æ›´ãƒ»å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ãƒã‚§ãƒƒã‚¯
      const modRequest = parseModificationRequest(input);
      if (modRequest) {
        if (modRequest.error) {
          addMessage('system', modRequest.error);
          return;
        }

        if (modRequest.type === 'delete') {
          const confirmText = `${formatScheduleDisplay(modRequest.target)} ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
          addMessage('confirm', confirmText, 'confirm');
          pendingAction = modRequest;
          setInputEnabled(false);
          return;
        }

        if (modRequest.type === 'modify') {
          // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
          if (isDuplicate(modRequest.newSchedule, modRequest.target)) {
            addMessage('system', 'ã“ã®æ™‚é–“ã«æ—¢ã«åŒã˜äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚');
            return;
          }

          // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
          const nearby = findNearbySchedule(modRequest.newSchedule, modRequest.target);
          if (nearby) {
            const confirmText = `${formatScheduleDisplay(modRequest.target)} â†’ ${formatScheduleDisplay(modRequest.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ<br><span style="color:#e74c3c">âš  ${formatScheduleDisplay(nearby)} ã®2æ™‚é–“ä»¥å†…ã«äºˆå®šãŒã‚ã‚Šã¾ã™</span>`;
            addMessage('confirm', confirmText, 'modify-warning');
            pendingAction = modRequest;
            setInputEnabled(false);
            return;
          }

          const confirmText = `${formatScheduleDisplay(modRequest.target)} â†’ ${formatScheduleDisplay(modRequest.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ`;
          addMessage('confirm', confirmText, 'confirm');
          pendingAction = modRequest;
          setInputEnabled(false);
          return;
        }
      }

      // æ–°è¦è¿½åŠ 
      const isOther = input.startsWith('(') || input.startsWith('ï¼ˆ');
      const cleanInput = input.replace(/^[ï¼ˆ(]|[)ï¼‰]$/g, '');

      // è¤‡æ•°äºˆå®šã‹ãƒã‚§ãƒƒã‚¯
      const multipleSchedules = parseMultipleSchedules(cleanInput);
      if (multipleSchedules) {
        multipleSchedules.forEach(s => s.isOther = isOther);
        const originalCount = multipleSchedules.length;

        // æ—¢å­˜äºˆå®šã¨ã®é‡è¤‡ã®ã¿è‡ªå‹•é™¤å¤–ï¼ˆå…¥åŠ›å†…ã®é‡è¤‡ã¯é¸æŠå¼ã§ç¢ºèªï¼‰
        const uniqueSchedules = [];
        let existingDupCount = 0;
        for (const s of multipleSchedules) {
          const isDupInExisting = isDuplicate(s);
          if (!isDupInExisting) {
            uniqueSchedules.push(s);
          } else {
            existingDupCount++;
          }
        }

        if (uniqueSchedules.length === 0) {
          addMessage('system', `${originalCount}ä»¶å…¨ã¦æ—¢ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚`);
          return;
        }

        // æ—¢å­˜äºˆå®šã¨ã®é‡è¤‡é™¤å¤–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        if (existingDupCount > 0) {
          addMessage('system', `${existingDupCount}ä»¶ã¯æ—¢ã«ç™»éŒ²æ¸ˆã¿ã®ãŸã‚é™¤å¤–ã—ã¾ã—ãŸã€‚`);
        }

        // å®Œå…¨é‡è¤‡ã¨ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆåŒä¸€æ—¥æ™‚ã®äºˆå®šï¼‰
        const conflicts = findSameTimeConflicts(uniqueSchedules);

        if (conflicts.length > 0) {
          // è¡çªè§£æ±ºãƒ¢ãƒ¼ãƒ‰ã¸
          pendingAction = {
            type: 'resolve-conflict',
            allSchedules: uniqueSchedules,
            conflicts: conflicts,
            schedulesToRemove: new Set(),
            currentConflict: null
          };
          setInputEnabled(false);
          processNextConflict();
          return;
        }

        // è¡çªãªã— â†’ æœ€çµ‚ç¢ºèª
        const listText = uniqueSchedules.map(s => formatScheduleDisplay(s)).join('<br>');
        const confirmText = `${uniqueSchedules.length}ä»¶ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ<br>${listText}`;
        addMessage('confirm', confirmText, 'confirm');
        pendingAction = { type: 'add-multiple', schedules: uniqueSchedules };
        setInputEnabled(false);
        return;
      }

      // å˜ä¸€äºˆå®š
      const parsed = parseScheduleInput(cleanInput);
      if (parsed) {
        parsed.isOther = isOther;

        // é‡è¤‡ãƒã‚§ãƒƒã‚¯
        if (isDuplicate(parsed)) {
          const confirmText = `${formatScheduleDisplay(parsed)} ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚`;
          addMessage('confirm', confirmText, 'duplicate');
          pendingAction = { type: 'duplicate', schedule: parsed };
          setInputEnabled(false);
        } else {
          // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†ã®äºˆå®šã®ã¿ï¼‰
          const nearby = findNearbySchedule(parsed);
          if (nearby) {
            const confirmText = `${formatScheduleDisplay(nearby)} ã®2æ™‚é–“ä»¥å†…ã«äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`;
            addMessage('confirm', confirmText, 'warning');
            pendingAction = { type: 'warning', schedule: parsed };
            setInputEnabled(false);
          } else {
            const confirmText = `${formatScheduleDisplay(parsed)} ã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`;
            addMessage('confirm', confirmText, 'confirm');
            pendingAction = { type: 'add', schedule: parsed };
            setInputEnabled(false);
          }
        }
      } else {
        addMessage('system', 'æ—¥ä»˜ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã€Œæ¥é€±ã®é‡‘æ›œæ—¥ã€ã€Œæ˜æ—¥ã€ã€Œ1/15ã€ã€Œä»Šæœˆæœ«ã€ãªã©ã‚’å«ã‚ã¦ãã ã•ã„ã€‚');
      }
    });

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ï¼ˆ2æ®µéšç¢ºèªï¼‰
    document.getElementById('resetBtn').addEventListener('click', () => {
      if (schedules.length === 0) {
        addMessage('system', 'å‰Šé™¤ã™ã‚‹äºˆå®šãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        return;
      }
      if (confirm('æœ¬å½“ã«å…¨ã¦ã®äºˆå®šã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
        if (confirm('ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
          schedules = [];
          localStorage.setItem('schedules', JSON.stringify(schedules));
          addMessage('system', 'å…¨ã¦ã®äºˆå®šã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
        }
      }
    });

    // åˆæœŸåŒ–
    function initializeApp() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const todayStr = `${today.getMonth() + 1}/${today.getDate()}`;

      // éå»ã®äºˆå®šã‚’å‰Šé™¤
      const originalCount = schedules.length;
      schedules = schedules.filter(s => {
        const scheduleDate = new Date(s.fullDate);
        const scheduleDateOnly = new Date(scheduleDate.getFullYear(), scheduleDate.getMonth(), scheduleDate.getDate());
        return scheduleDateOnly >= today;
      });

      const removedCount = originalCount - schedules.length;
      if (removedCount > 0) {
        localStorage.setItem('schedules', JSON.stringify(schedules));
      }

      // å½“æ—¥ã®äºˆå®šã‚’å–å¾—
      const todaySchedules = schedules
        .filter(s => s.date === todayStr)
        .sort((a, b) => (a.time || '0000') > (b.time || '0000') ? 1 : -1);

      // ä»Šå¾Œã®äºˆå®šï¼ˆå½“æ—¥ä»¥é™ï¼‰
      const futureSchedules = schedules
        .filter(s => s.date !== todayStr)
        .sort((a, b) => {
          const dateA = new Date(a.fullDate);
          const dateB = new Date(b.fullDate);
          if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
          return (a.time || '0000') > (b.time || '0000') ? 1 : -1;
        });

      // æŒ¨æ‹¶ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      let greeting = 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼<br><br>';

      // æœ¬æ—¥ã®äºˆå®š
      if (todaySchedules.length > 0) {
        greeting += 'æœ¬æ—¥ã®äºˆå®šï¼š<br>';
        todaySchedules.forEach((s, idx) => {
          const timeStr = s.time ? `${s.time} ` : '';
          const content = s.isOther ? `(${timeStr}${s.title})` : `${timeStr}${s.title}`;
          if (idx === 0) {
            greeting += `${s.date} ${content}<br>`;
          } else {
            greeting += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${content}<br>`;
          }
        });
      } else {
        greeting += 'æœ¬æ—¥ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<br>';
      }

      // ä»Šå¾Œã®äºˆå®š
      if (futureSchedules.length > 0) {
        greeting += '<br>ä»Šå¾Œã®äºˆå®šï¼š<br>';
        const grouped = {};
        futureSchedules.forEach(s => {
          if (!grouped[s.date]) grouped[s.date] = [];
          grouped[s.date].push(s);
        });
        Object.keys(grouped).forEach(date => {
          grouped[date].forEach((s, idx) => {
            const timeStr = s.time ? `${s.time} ` : '';
            const content = s.isOther ? `(${timeStr}${s.title})` : `${timeStr}${s.title}`;
            if (idx === 0) {
              greeting += `${date} ${content}<br>`;
            } else {
              greeting += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${content}<br>`;
            }
          });
        });
      }

      addMessage('system', `<div class="schedule-text">${greeting}</div>`);

      // å…¥åŠ›ä¾‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      const helpText = `äºˆå®šã‚’å…¥åŠ›ã—ã¦ã­ï¼<br><br>` +
        `ğŸ“ è¿½åŠ ï¼š1/20 1400 ä¼šè­°<br>` +
        `ğŸ“‹ ç¢ºèªï¼šäºˆå®š<br>` +
        `ğŸ—‘ï¸ å‰Šé™¤ï¼š1/20ã®ä¼šè­°ã‚’å‰Šé™¤<br>` +
        `âœï¸ å¤‰æ›´ï¼š1/20ã®ä¼šè­°ã‚’1500ã«å¤‰æ›´`;
      addMessage('system', helpText);

      // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜æ—¥æ™‚ã«è‡ªåˆ†ã®äºˆå®šãŒè¤‡æ•°ã‚ã‚‹å ´åˆï¼‰
      const doubleBookings = findDoubleBookings();
      if (doubleBookings.length > 0) {
        pendingAction = {
          type: 'resolve-double-booking',
          conflicts: doubleBookings,
          conflictIndex: 0,
          currentConflict: null
        };
        setInputEnabled(false);
        showNextDoubleBooking();
      }
    }

    initializeApp();

    // Service Workerç™»éŒ²
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .catch(err => console.error('SW registration failed:', err));
    }
  </script>
</body>
</html>
