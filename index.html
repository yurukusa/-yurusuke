<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ã‚†ã‚‹ã‚¹ã‚±</title>
  <!-- PWA -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#667eea">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="ã‚†ã‚‹ã‚¹ã‚±">
  <link rel="apple-touch-icon" href="icon-192.svg">
  <meta name="description" content="ã‚†ã‚‹ãäºˆå®šã‚’ç®¡ç†ã™ã‚‹ã‚¢ãƒ—ãƒª">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      min-height: 100dvh;
    }
    .app {
      max-width: 600px;
      margin: 0 auto;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      background: #fff;
    }
    header {
      background: #4a90d9;
      color: white;
      padding: 12px 16px;
      position: sticky;
      top: 0;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 { font-size: 18px; font-weight: 600; }
    .header-buttons {
      display: flex;
      gap: 8px;
    }
    .header-btn {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.4);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }
    .header-btn.icon-btn {
      padding: 6px 10px;
      font-size: 16px;
    }
    .header-btn:hover { background: rgba(255,255,255,0.3); }
    .header-btn.support-icon {
      background: #ff9500;
      border-color: #ff9500;
    }
    .header-btn.support-icon:hover {
      background: #e68600;
    }
    .popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    .popup {
      background: white;
      border-radius: 12px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    .popup-header {
      background: #4a90d9;
      color: white;
      padding: 12px 16px;
      font-weight: 600;
      border-radius: 12px 12px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .popup-close {
      background: none;
      border: none;
      color: white;
      font-size: 20px;
      cursor: pointer;
      padding: 0 4px;
    }
    .popup-content {
      padding: 16px;
      line-height: 1.8;
      font-size: 14px;
    }
    .popup-content h3 {
      color: #4a90d9;
      margin-top: 16px;
      margin-bottom: 8px;
      font-size: 15px;
    }
    .popup-content h3:first-child {
      margin-top: 0;
    }
    .popup-content .example {
      color: #666;
      margin-left: 8px;
    }
    .settings-item {
      padding: 12px 0;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .settings-item:last-child {
      border-bottom: none;
    }
    .settings-item.disabled {
      color: #999;
    }
    .settings-item .badge {
      background: #e0e0e0;
      color: #666;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    .data-btn {
      width: 100%;
      padding: 12px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 8px;
    }
    .data-btn:hover {
      background: #0056b3;
    }
    .data-btn:first-of-type {
      margin-top: 16px;
    }
    .support-btn {
      width: 100%;
      padding: 12px;
      background: #ff9500;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 16px;
      text-decoration: none;
      display: block;
      text-align: center;
    }
    .support-btn:hover {
      background: #e68600;
    }
    .delete-all-btn {
      width: 100%;
      padding: 12px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 8px;
    }
    .delete-all-btn:hover {
      background: #c82333;
    }
    .main-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .message {
      max-width: 85%;
      padding: 10px 14px;
      border-radius: 16px;
      line-height: 1.4;
      font-size: 15px;
    }
    .message.user {
      align-self: flex-end;
      background: #4a90d9;
      color: white;
      border-bottom-right-radius: 4px;
    }
    .message.system {
      align-self: flex-start;
      background: #e8e8e8;
      color: #333;
      border-bottom-left-radius: 4px;
    }
    .message.confirm {
      align-self: flex-start;
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffc107;
      border-bottom-left-radius: 4px;
    }
    .confirm-buttons {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }
    .confirm-buttons button {
      flex: 1;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-ok { background: #28a745; color: white; }
    .btn-cancel { background: #dc3545; color: white; }
    .btn-delete { background: #dc3545; color: white; }
    .btn-skip { background: #6c757d; color: white; }
    .btn-add { background: #007bff; color: white; }
    .input-form {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      background: #fff;
      border-top: 1px solid #e0e0e0;
    }
    .input-form input {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ddd;
      border-radius: 24px;
      font-size: 16px;
      outline: none;
    }
    .input-form input:focus { border-color: #4a90d9; }
    .input-form input:disabled { background: #f5f5f5; }
    .input-form button {
      padding: 12px 20px;
      background: #4a90d9;
      color: white;
      border: none;
      border-radius: 24px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
    }
    .input-form button:disabled { background: #ccc; }
    .voice-btn {
      padding: 12px 14px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 24px;
      font-size: 18px;
      cursor: pointer;
    }
    .voice-btn:hover { background: #5a6268; }
    .voice-btn.recording {
      background: #dc3545;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .schedule-text {
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Consolas', monospace;
      line-height: 1.8;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .schedule-text .other-schedule {
      color: #999;
    }
    @supports (padding-bottom: env(safe-area-inset-bottom)) {
      .input-form {
        padding-bottom: calc(12px + env(safe-area-inset-bottom));
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="header-buttons">
        <button class="header-btn icon-btn" id="settingsBtn">âš™</button>
        <button class="header-btn" id="helpBtn">ä½¿ã„æ–¹</button>
      </div>
      <h1>ã‚†ã‚‹ã‚¹ã‚±</h1>
      <a href="https://ko-fi.com/yurukusa" target="_blank" rel="noopener noreferrer" class="header-btn icon-btn support-icon">â˜•</a>
    </header>

    <!-- ä½¿ã„æ–¹ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
    <div class="popup-overlay" id="helpPopup" style="display: none;">
      <div class="popup">
        <div class="popup-header">
          <span>ä½¿ã„æ–¹</span>
          <button class="popup-close" onclick="closePopup('helpPopup')">Ã—</button>
        </div>
        <div class="popup-content">
          <h3>ã€äºˆå®šã‚’è¿½åŠ ã™ã‚‹ã€‘</h3>
          æ—¥ä»˜ã¨æ™‚é–“ã¨å†…å®¹ã‚’å…¥åŠ›ã—ã¦ã­<br>
          <span class="example">ä¾‹ï¼š1/20 1400 ä¼šè­°</span><br>
          <span class="example">ä¾‹ï¼šæ˜æ—¥ 18æ™‚ é£²ã¿ä¼š</span>

          <h3>ã€äºˆå®šã‚’ç¢ºèªã™ã‚‹ã€‘</h3>
          ã€Œäºˆå®šã€ã¨å…¥åŠ›ã—ã¦ã­

          <h3>ã€äºˆå®šã‚’å‰Šé™¤ã™ã‚‹ã€‘</h3>
          æ—¥ä»˜ã¨å†…å®¹ã‚’å…¥åŠ›ã—ã¦ã€Œå‰Šé™¤ã€ã‚’ã¤ã‘ã¦ã­<br>
          <span class="example">ä¾‹ï¼š1/20ã®ä¼šè­°ã‚’å‰Šé™¤</span>

          <h3>ã€äºˆå®šã‚’å¤‰æ›´ã™ã‚‹ã€‘</h3>
          <span class="example">ä¾‹ï¼š1/20ã®ä¼šè­°ã‚’1500ã«å¤‰æ›´</span><br>
          <span class="example">ä¾‹ï¼š1/20ã®ä¼šè­°ã‚’1/21ã«å¤‰æ›´</span>

          <h3>ã€ä»–äººã®äºˆå®šã‚’è¿½åŠ ã™ã‚‹ã€‘</h3>
          ã‚«ãƒƒã‚³ã§å›²ã‚€ã‹ã€æœ€å¾Œã«ã€Œä»–äººã®äºˆå®šã€ã‚’ã¤ã‘ã¦ã­<br>
          <span class="example">ä¾‹ï¼š1/20 (1400 å­ä¾›ã®ç¿’ã„äº‹)</span><br>
          <span class="example">ä¾‹ï¼š1/20 1400 å­ä¾›ã®ç¿’ã„äº‹ ä»–äººã®äºˆå®š</span>
        </div>
      </div>
    </div>

    <!-- è¨­å®šãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
    <div class="popup-overlay" id="settingsPopup" style="display: none;">
      <div class="popup">
        <div class="popup-header">
          <span>è¨­å®š</span>
          <button class="popup-close" onclick="closePopup('settingsPopup')">Ã—</button>
        </div>
        <div class="popup-content">
          <div class="settings-item disabled">
            <span>ã‚¢ã‚«ã‚¦ãƒ³ãƒˆé€£æº</span>
            <span class="badge">æº–å‚™ä¸­</span>
          </div>
          <div class="settings-item disabled">
            <span>Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é€£æº</span>
            <span class="badge">æº–å‚™ä¸­</span>
          </div>
          <div class="settings-item disabled">
            <span>è¨€èªè¨­å®š</span>
            <span class="badge">æº–å‚™ä¸­</span>
          </div>
          <button class="data-btn" id="exportBtn">ğŸ“¤ äºˆå®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
          <button class="data-btn" id="importBtn">ğŸ“¥ äºˆå®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
          <input type="file" id="importFile" accept=".json" style="display: none;">
          <a href="https://ko-fi.com/yurukusa" target="_blank" rel="noopener noreferrer" class="support-btn">â˜• é–‹ç™ºã‚’å¿œæ´ã™ã‚‹</a>
          <button class="delete-all-btn" id="deleteAllBtn">å…¨ã¦ã®äºˆå®šã‚’å‰Šé™¤</button>
        </div>
      </div>
    </div>
    <div class="main-container">
      <div class="chat-section">
        <div class="messages" id="messages"></div>
        <form class="input-form" id="inputForm">
          <input type="text" id="inputField" placeholder="äºˆå®šã‚’å…¥åŠ›..." autocomplete="off">
          <button type="button" class="voice-btn" id="voiceBtn">ğŸ¤</button>
          <button type="submit">é€ä¿¡</button>
        </form>
      </div>
    </div>
  </div>

  <script>
    // çŠ¶æ…‹ç®¡ç†
    let schedules = JSON.parse(localStorage.getItem('schedules') || '[]');
    let pendingAction = null; // { type: 'add'|'modify'|'delete', ... }

    // DOMè¦ç´ 
    const messagesEl = document.getElementById('messages');
    const inputForm = document.getElementById('inputForm');
    const inputField = document.getElementById('inputField');

    // ============================================
    // æ—¥ä»˜ãƒ»æ™‚é–“ãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆéƒ¨å“ã¨ã—ã¦ä½¿ç”¨ï¼‰
    // ============================================
    function parseDateFromText(input) {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      let date = null;
      let consumed = '';

      const weekdayMap = { 'æ—¥': 0, 'æœˆ': 1, 'ç«': 2, 'æ°´': 3, 'æœ¨': 4, 'é‡‘': 5, 'åœŸ': 6 };

      // ä»Šæœˆæœ« / æ¥æœˆæœ« / å†æ¥æœˆæœ«
      const monthEndMatch = input.match(/(ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)æœ«/);
      if (monthEndMatch && !date) {
        date = new Date(today);
        if (monthEndMatch[1] === 'æ¥æœˆ') date.setMonth(date.getMonth() + 1);
        else if (monthEndMatch[1] === 'å†æ¥æœˆ') date.setMonth(date.getMonth() + 2);
        date = new Date(date.getFullYear(), date.getMonth() + 1, 0);
        consumed = monthEndMatch[0];
      }

      // ä»Šæœˆé ­ / æ¥æœˆé ­
      const monthStartMatch = input.match(/(ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)(é ­|åˆã‚?|ã‚ãŸã¾|ã¯ã˜ã‚)/);
      if (monthStartMatch && !date) {
        date = new Date(today);
        if (monthStartMatch[1] === 'ä»Šæœˆ' && today.getDate() > 5) date.setMonth(date.getMonth() + 1);
        else if (monthStartMatch[1] === 'æ¥æœˆ') date.setMonth(date.getMonth() + 1);
        else if (monthStartMatch[1] === 'å†æ¥æœˆ') date.setMonth(date.getMonth() + 2);
        date.setDate(1);
        consumed = monthStartMatch[0];
      }

      // æ¥é€±/ä»Šé€±/å†æ¥é€± + æ›œæ—¥
      const weekMatch = input.match(/(æ¥é€±|ä»Šé€±|å†æ¥é€±)ã®?([æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ])æ›œ?æ—¥?/);
      if (weekMatch && !date) {
        const weekOffset = weekMatch[1] === 'æ¥é€±' ? 1 : weekMatch[1] === 'å†æ¥é€±' ? 2 : 0;
        const targetDay = weekdayMap[weekMatch[2]];
        date = new Date(today);
        let daysToAdd = targetDay - date.getDay();
        if (daysToAdd <= 0 && weekOffset === 0) daysToAdd += 7;
        date.setDate(date.getDate() + daysToAdd + weekOffset * 7);
        consumed = weekMatch[0];
      }

      // ä»Šåº¦ã®/æ¬¡ã® + æ›œæ—¥
      const nextWeekdayMatch = input.match(/(ä»Šåº¦|æ¬¡)ã®?([æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ])æ›œ?æ—¥?/);
      if (nextWeekdayMatch && !date) {
        const targetDay = weekdayMap[nextWeekdayMatch[2]];
        date = new Date(today);
        let daysToAdd = targetDay - date.getDay();
        if (daysToAdd <= 0) daysToAdd += 7;
        date.setDate(date.getDate() + daysToAdd);
        consumed = nextWeekdayMatch[0];
      }

      // æ˜æ—¥/æ˜å¾Œæ—¥/ã‚ã•ã£ã¦/ã—ã‚ã•ã£ã¦/ä»Šæ—¥
      const dayPatterns = [
        { regex: /ã—ã‚ã•ã£ã¦/, days: 3 },
        { regex: /(æ˜å¾Œæ—¥|ã‚ã•ã£ã¦)/, days: 2 },
        { regex: /æ˜æ—¥/, days: 1 },
        { regex: /ä»Šæ—¥/, days: 0 },
      ];
      for (const { regex, days } of dayPatterns) {
        const match = input.match(regex);
        if (match && !date) {
          date = new Date(today);
          date.setDate(date.getDate() + days);
          consumed = match[0];
          break;
        }
      }

      // Xæ—¥å¾Œ / Xé€±é–“å¾Œ
      const daysLaterMatch = input.match(/(\d+)æ—¥å¾Œ/);
      if (daysLaterMatch && !date) {
        date = new Date(today);
        date.setDate(date.getDate() + parseInt(daysLaterMatch[1]));
        consumed = daysLaterMatch[0];
      }

      const weeksLaterMatch = input.match(/(\d+)é€±é–“?å¾Œ/);
      if (weeksLaterMatch && !date) {
        date = new Date(today);
        date.setDate(date.getDate() + parseInt(weeksLaterMatch[1]) * 7);
        consumed = weeksLaterMatch[0];
      }

      // MæœˆDæ—¥ ã¾ãŸã¯ M/D
      const dateMatch = input.match(/(\d{1,2})[\/æœˆ](\d{1,2})æ—¥?/);
      if (dateMatch && !date) {
        date = new Date(today.getFullYear(), parseInt(dateMatch[1]) - 1, parseInt(dateMatch[2]));
        if (date < today) date.setFullYear(date.getFullYear() + 1);
        consumed = dateMatch[0];
      }

      return date ? { date, consumed } : null;
    }

    function parseTimeFromText(input) {
      let time = null;
      let consumed = '';

      const timePatterns = [
        { regex: /(\d{1,2})[æ™‚:](\d{2})åˆ†?/, handler: (m) => ({ h: parseInt(m[1]), m: parseInt(m[2]) }) },
        { regex: /(\d{1,2})æ™‚åŠ/, handler: (m) => ({ h: parseInt(m[1]), m: 30 }) },
        { regex: /(\d{1,2})æ™‚/, handler: (m) => ({ h: parseInt(m[1]), m: 0 }) },
        { regex: /(?<![\/\d])(\d{3,4})(?!\d|æ—¥|å¹´|æœˆ)/, handler: (m) => {
          const t = m[1].padStart(4, '0');
          const h = parseInt(t.slice(0, 2));
          const min = parseInt(t.slice(2));
          if (h >= 0 && h <= 23 && min >= 0 && min <= 59) return { h, m: min };
          return null;
        }},
      ];

      for (const { regex, handler } of timePatterns) {
        const match = input.match(regex);
        if (match) {
          const result = handler(match);
          if (result) {
            time = result;
            consumed = match[0];
            break;
          }
        }
      }

      if (!time) {
        const vagueTimePatterns = [
          { regex: /æ—©æœ/, hour: 6 },
          { regex: /æœ/, hour: 9 },
          { regex: /åˆå‰ä¸­?/, hour: 10 },
          { regex: /ãŠæ˜¼|æ˜¼/, hour: 12 },
          { regex: /åˆå¾Œ/, hour: 14 },
          { regex: /å¤•æ–¹|å¤•/, hour: 17 },
          { regex: /å¤œ|æ™©|å¤œé–“/, hour: 19 },
          { regex: /æ·±å¤œ/, hour: 23 },
        ];
        for (const { regex, hour } of vagueTimePatterns) {
          const match = input.match(regex);
          if (match) {
            time = { h: hour, m: 0 };
            consumed = match[0];
            break;
          }
        }
      }

      return time ? { time, consumed } : null;
    }

    function formatTime(time) {
      return time ? `${String(time.h).padStart(2, '0')}${String(time.m).padStart(2, '0')}` : null;
    }

    // ============================================
    // äºˆå®šè¿½åŠ ãƒ‘ãƒ¼ã‚µãƒ¼
    // ============================================
    function parseScheduleInput(input) {
      let title = input;

      // ã‚«ãƒƒã‚³ä»˜ãã®äºˆå®šã‚’æ¤œå‡ºï¼ˆä¾‹ï¼š12/14 (0800 ãƒ‰ãƒªãƒ•)ã€1/17 (1000 ã‚Œã„ãªä¸€æ™‚ä¿è‚²)ï¼‰
      const parenMatch = input.match(/^(.+?)\s*[ï¼ˆ(](\d{3,4})\s+(.+?)[)ï¼‰]$/);
      if (parenMatch) {
        const dateStr = parenMatch[1].trim();
        const timeStr = parenMatch[2].padStart(4, '0');
        const titleInParen = parenMatch[3].trim();

        const h = parseInt(timeStr.slice(0, 2));
        const m = parseInt(timeStr.slice(2));
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
          const dateResult = parseDateFromText(dateStr);
          if (dateResult) {
            const result = {
              date: `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`,
              time: timeStr,
              title: titleInParen,
              fullDate: dateResult.date.toISOString(),
              isOther: true
            };
            return result;
          }
        }
      }

      // æ™‚é–“ãŒã‚«ãƒƒã‚³å¤–ã€ã‚¿ã‚¤ãƒˆãƒ«ã®ã¿ã‚«ãƒƒã‚³å†…ï¼ˆä¾‹ï¼š12/14 0800 (ãƒ‰ãƒªãƒ•)ï¼‰
      const timeOutsideParenMatch = input.match(/^(.+?)\s+(\d{3,4})\s*[ï¼ˆ(](.+?)[)ï¼‰]$/);
      if (timeOutsideParenMatch) {
        const dateStr = timeOutsideParenMatch[1].trim();
        const timeStr = timeOutsideParenMatch[2].padStart(4, '0');
        const titleInParen = timeOutsideParenMatch[3].trim();

        const h = parseInt(timeStr.slice(0, 2));
        const m = parseInt(timeStr.slice(2));
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
          const dateResult = parseDateFromText(dateStr);
          if (dateResult) {
            const result = {
              date: `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`,
              time: timeStr,
              title: titleInParen,
              fullDate: dateResult.date.toISOString(),
              isOther: true
            };
            return result;
          }
        }
      }

      // å…ˆé ­ã«ç„¡é–¢ä¿‚ãªæ–‡å­—ãŒã‚ã‚‹å ´åˆã€æ—¥ä»˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä½ç½®ã‚’æ¢ã™
      const datePatternForSearch = /(\d{1,2}[\/æœˆ]\d{1,2}æ—¥?|(?:ä»Šæ—¥|æ˜æ—¥|æ˜å¾Œæ—¥|ã‚ã•ã£ã¦|ã—ã‚ã•ã£ã¦)|(?:æ¥é€±|ä»Šé€±|å†æ¥é€±)ã®?[æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ]æ›œ?æ—¥?|(?:ä»Šåº¦|æ¬¡)ã®?[æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ]æ›œ?æ—¥?|\d+æ—¥å¾Œ|\d+é€±é–“?å¾Œ|(?:ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)(?:æœ«|é ­|åˆã‚?|ã‚ãŸã¾|ã¯ã˜ã‚))/;
      const dateMatch = input.match(datePatternForSearch);

      let inputForParse = input;
      let prefixRemoved = '';
      if (dateMatch && dateMatch.index > 0) {
        // æ—¥ä»˜ã®å‰ã«ã‚ã‚‹æ–‡å­—ã‚’é™¤å»
        prefixRemoved = input.slice(0, dateMatch.index);
        inputForParse = input.slice(dateMatch.index);
      }

      const dateResult = parseDateFromText(inputForParse);
      if (!dateResult) return null;

      title = inputForParse.replace(dateResult.consumed, '').trim();

      const timeResult = parseTimeFromText(title);
      if (timeResult) {
        title = title.replace(timeResult.consumed, '').trim();
      }

      // ã‚¿ã‚¤ãƒˆãƒ«ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      title = title
        .replace(/^[ã€,ã®ã«ã¯ã¸ã¨]\s*/, '')
        .replace(/\s*[ã€,ã®ã«ã¯ã¸ã¨]$/, '')
        .replace(/[ã€,]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();

      // æœ«å°¾ã«ã€Œä»–äººã®äºˆå®šã€ã€Œå®¶æ—ã®äºˆå®šã€ãŒã‚ã‚Œã°isOther: true
      let isOther = false;
      const otherMatch = title.match(/[\sã€€]*(ä»–äººã®äºˆå®š|å®¶æ—ã®äºˆå®š)$/);
      if (otherMatch) {
        isOther = true;
        title = title.replace(otherMatch[0], '').trim();
      }

      return {
        date: `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`,
        time: timeResult ? formatTime(timeResult.time) : 'æœªå®š',
        title: title || 'äºˆå®š',
        fullDate: dateResult.date.toISOString(),
        isOther: isOther
      };
    }

    // ============================================
    // è¤‡æ•°äºˆå®šãƒ‘ãƒ¼ã‚µãƒ¼
    // ============================================
    // æ—¥ä»˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ­£è¦è¡¨ç¾ï¼ˆåˆ†å‰²ç”¨ï¼‰
    const datePatternRegex = /(\d{1,2}[\/æœˆ]\d{1,2}æ—¥?|(?:ä»Šæ—¥|æ˜æ—¥|æ˜å¾Œæ—¥|ã‚ã•ã£ã¦|ã—ã‚ã•ã£ã¦)|(?:æ¥é€±|ä»Šé€±|å†æ¥é€±)ã®?[æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ]æ›œ?æ—¥?|(?:ä»Šåº¦|æ¬¡)ã®?[æ—¥æœˆç«æ°´æœ¨é‡‘åœŸ]æ›œ?æ—¥?|\d+æ—¥å¾Œ|\d+é€±é–“?å¾Œ|(?:ä»Šæœˆ|æ¥æœˆ|å†æ¥æœˆ)(?:æœ«|é ­|åˆã‚?|ã‚ãŸã¾|ã¯ã˜ã‚))/g;

    // ç„¡åŠ¹ãªã‚¿ã‚¤ãƒˆãƒ«ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
    function isInvalidTitle(title) {
      if (!title) return true;
      // ã€Œäºˆå®šã€ã®ã¿ã€ã¾ãŸã¯1-3æ¡ã®æ•°å­—ã®ã¿ã¯ç„¡åŠ¹
      if (title === 'äºˆå®š') return true;
      if (/^\d{1,3}$/.test(title)) return true;
      return false;
    }

    function parseMultipleSchedules(input) {
      // å…ˆé ­ã®ã€Œäºˆå®šï¼ã€ã€Œäºˆå®š! ã€ãªã©ã‚’é™¤å»
      let workInput = input.replace(/^äºˆå®š[ï¼!]?\s*/, '');

      // å…ˆé ­ã®ç„¡é–¢ä¿‚ãªæ–‡å­—ã‚’é™¤å»ï¼ˆæ—¥ä»˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™ï¼‰
      const firstDateMatch = workInput.match(datePatternRegex);
      if (!firstDateMatch) return null;

      if (firstDateMatch.index > 0) {
        workInput = workInput.slice(firstDateMatch.index);
      }

      // ã‚«ãƒƒã‚³ä»˜ãäºˆå®šã‚’å…ˆã«æŠ½å‡ºï¼ˆã‚«ãƒƒã‚³å†…ã‚’ä¿è­·ï¼‰
      // ã€Œ(1000 ã‚Œã„ãª)ã€ã€Œ(1000ã‚Œã„ãª)ã€ä¸¡æ–¹ã«å¯¾å¿œ
      const parenSchedules = [];
      const parenRanges = []; // ã‚«ãƒƒã‚³ã®ç¯„å›²ã‚’è¨˜éŒ²
      const fullParenRegex = /[ï¼ˆ(](\d{3,4})\s*(.+?)[)ï¼‰]/g;
      let parenMatch;
      while ((parenMatch = fullParenRegex.exec(workInput)) !== null) {
        const timeStr = parenMatch[1].padStart(4, '0');
        const h = parseInt(timeStr.slice(0, 2));
        const m = parseInt(timeStr.slice(2));
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
          parenSchedules.push({
            index: parenMatch.index,
            endIndex: parenMatch.index + parenMatch[0].length,
            time: timeStr,
            title: parenMatch[2].trim(),
            isOther: true
          });
          parenRanges.push({ start: parenMatch.index, end: parenMatch.index + parenMatch[0].length });
        }
      }

      // ã‚«ãƒƒã‚³ç¯„å›²å†…ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
      function isInsideParen(index) {
        return parenRanges.some(r => index > r.start && index < r.end);
      }

      // åŒºåˆ‡ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä½ç½®ã‚’æ¤œå‡º
      const allMatches = [];

      // æ—¥ä»˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºï¼ˆã‚«ãƒƒã‚³å†…ã¯é™¤å¤–ï¼‰
      const dateMatches = [...workInput.matchAll(datePatternRegex)];
      dateMatches.forEach(m => {
        if (!isInsideParen(m.index)) {
          allMatches.push({ index: m.index, type: 'date', match: m[0] });
        }
      });

      // ã‚«ãƒƒã‚³ä»˜ãäºˆå®šã®é–‹å§‹ä½ç½®ã‚’è¿½åŠ 
      parenSchedules.forEach(ps => {
        allMatches.push({ index: ps.index, type: 'paren', parenData: ps });
      });

      // æ™‚é–“ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç©ºç™½å¾Œã®4æ¡æ•°å­—ï¼‰ã‚’æ¤œå‡ºï¼ˆã‚«ãƒƒã‚³å†…ã¯é™¤å¤–ï¼‰
      const timeRegex = /\s(\d{4})(?=\s|$|\D)/g;
      let match;
      while ((match = timeRegex.exec(workInput)) !== null) {
        const timeIndex = match.index + 1;
        if (isInsideParen(timeIndex)) continue;

        const timeStr = match[1];
        const h = parseInt(timeStr.slice(0, 2));
        const m = parseInt(timeStr.slice(2));
        if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
          // æ—¥ä»˜ã®ç›´å¾Œã§ã¯ãªã„æ™‚é–“ã®ã¿
          const isAfterDate = dateMatches.some(dm => {
            const dmEnd = dm.index + dm[0].length;
            return timeIndex > dmEnd && timeIndex <= dmEnd + 2;
          });
          if (!isAfterDate) {
            allMatches.push({ index: timeIndex, type: 'time', match: timeStr });
          }
        }
      }

      // ã‚½ãƒ¼ãƒˆã—ã¦é‡è¤‡ã‚’é™¤å»
      allMatches.sort((a, b) => a.index - b.index);

      if (allMatches.length <= 1) {
        return null;
      }

      // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹
      const parsed = [];
      const skipped = []; // ã‚¹ã‚­ãƒƒãƒ—ã•ã‚ŒãŸäºˆå®šã‚’è¨˜éŒ²
      let lastDate = null;
      let lastFullDate = null;

      for (let i = 0; i < allMatches.length; i++) {
        const start = allMatches[i].index;
        const end = i < allMatches.length - 1 ? allMatches[i + 1].index : workInput.length;
        let segment = workInput.slice(start, end).trim();
        const matchType = allMatches[i].type;

        if (!segment) continue;

        // ã€Œ1/14 1900 (é£²ã¿ä¼š)ã€ã€Œ1/14 1900(é£²ã¿ä¼š)ã€ã€Œ1/14 1900( é£²ã¿ä¼š)ã€ã®ã‚ˆã†ãªå½¢å¼ã‚’å‡¦ç†
        // æ™‚é–“ã¨ã‚«ãƒƒã‚³ã®é–“ã®ã‚¹ãƒšãƒ¼ã‚¹ã¯ä»»æ„ã€ã‚«ãƒƒã‚³å†…ã®ã‚¿ã‚¤ãƒˆãƒ«å‰ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚‚ä»»æ„
        const timeParenMatch = segment.match(/^(\d{1,2}[\/æœˆ]\d{1,2}æ—¥?)\s+(\d{4})\s*[ï¼ˆ(]\s*(.+?)[)ï¼‰]$/);
        if (timeParenMatch) {
          const dateResult = parseDateFromText(timeParenMatch[1]);
          if (dateResult) {
            const title = timeParenMatch[3].trim();
            lastDate = `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`;
            lastFullDate = dateResult.date.toISOString();
            if (!isInvalidTitle(title)) {
              parsed.push({
                date: lastDate,
                time: timeParenMatch[2],
                title: title,
                fullDate: lastFullDate,
                isOther: true
              });
            } else {
              skipped.push(`${lastDate} ${timeParenMatch[2]} ${title || '(ç©º)'}`);
            }
            continue;
          }
        }

        // ã‚«ãƒƒã‚³ä»˜ãäºˆå®šï¼ˆä»–äººã®äºˆå®šï¼‰- äº‹å‰ã«æŠ½å‡ºã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
        if (matchType === 'paren') {
          const parenData = allMatches[i].parenData;
          if (parenData && lastDate) {
            if (!isInvalidTitle(parenData.title)) {
              parsed.push({
                date: lastDate,
                time: parenData.time,
                title: parenData.title,
                fullDate: lastFullDate,
                isOther: true
              });
            } else {
              skipped.push(`${lastDate} (${parenData.time} ${parenData.title || '(ç©º)'})`);
            }
          }
          continue;
        }

        // é€šå¸¸ã®æ—¥ä»˜ä»˜ãäºˆå®š
        if (matchType === 'date') {
          const schedule = parseScheduleInput(segment);
          if (schedule) {
            lastDate = schedule.date;
            lastFullDate = schedule.fullDate;
            if (!isInvalidTitle(schedule.title)) {
              parsed.push(schedule);
            } else {
              // æ¬¡ã®ãƒãƒƒãƒãŒã‚«ãƒƒã‚³ä»˜ãäºˆå®šã®å ´åˆã¯ã€æ—¥ä»˜ã®ã¿ã‚’è¨˜éŒ²ã—ã¦è­¦å‘Šã‚’å‡ºã•ãªã„
              const nextMatch = i < allMatches.length - 1 ? allMatches[i + 1] : null;
              const nextIsParen = nextMatch && nextMatch.type === 'paren';
              if (!nextIsParen) {
                const timeStr = schedule.time && schedule.time !== 'æœªå®š' ? ` ${schedule.time}` : '';
                skipped.push(`${schedule.date}${timeStr} ${schedule.title || '(ç©º)'}`);
              }
            }
          }
          continue;
        }

        // æ™‚é–“ã®ã¿ï¼ˆæ—¥ä»˜ã‚’å¼•ãç¶™ãï¼‰
        if (matchType === 'time' && lastDate) {
          const timeResult = parseTimeFromText(segment);
          if (timeResult) {
            let title = segment.replace(timeResult.consumed, '').trim();
            title = title.replace(/^[ã€,ã®ã«ã¯ã¸ã¨]\s*/, '').replace(/\s*[ã€,ã®ã«ã¯ã¸ã¨]$/, '').trim();

            // ã‚«ãƒƒã‚³ä»˜ãã‚¿ã‚¤ãƒˆãƒ«ã‚’æ¤œå‡ºï¼ˆä¾‹ï¼šã€Œ(é£²ã¿ä¼š)ã€ã€Œï¼ˆé£²ã¿ä¼šï¼‰ã€ï¼‰
            let isOtherSchedule = false;
            const parenTitleMatch = title.match(/^[ï¼ˆ(]\s*(.+?)\s*[)ï¼‰]$/);
            if (parenTitleMatch) {
              title = parenTitleMatch[1];
              isOtherSchedule = true;
            }

            if (!isInvalidTitle(title)) {
              parsed.push({
                date: lastDate,
                time: formatTime(timeResult.time),
                title: title,
                fullDate: lastFullDate,
                isOther: isOtherSchedule
              });
            } else {
              skipped.push(`${lastDate} ${formatTime(timeResult.time)} ${title || '(ç©º)'}`);
            }
          }
        }
      }

      if (parsed.length > 1) {
        return { schedules: parsed, skipped: skipped };
      }
      return null;
    }

    // ============================================
    // äºˆå®šæ¤œç´¢
    // ============================================
    function findSchedule(dateStr, timeStr, keyword) {
      // æ—¥ä»˜ãƒ»æ™‚é–“ãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§äºˆå®šã‚’æ¤œç´¢
      const matches = schedules.filter(s => {
        const dateMatch = !dateStr || s.date === dateStr;
        const timeMatch = !timeStr || s.time === timeStr;
        const keywordMatch = !keyword || s.title.includes(keyword);
        return dateMatch && timeMatch && keywordMatch;
      });
      return matches;
    }

    // ============================================
    // å¤‰æ›´ãƒ»å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒ‘ãƒ¼ã‚µãƒ¼
    // ============================================
    function parseModificationRequest(input) {
      // å¤‰æ›´ãƒ‘ã‚¿ãƒ¼ãƒ³1: ã€Œã€œã‚’ã€œã«å¤‰æ›´ã€ã€Œã€œã‚’ã€œã«ã—ã¦ã€ã€Œã€œã‚’ã€œã«ä¿®æ­£ã€
      const modifyMatch1 = input.match(/(.+?)[ã‚’ã®](.+?)[ã«ã¸](å¤‰æ›´|ã—ã¦|ã™ã‚‹|ç§»å‹•|å¤‰ãˆã¦|ä¿®æ­£|ç›´ã—ã¦|è¨‚æ­£)/);
      if (modifyMatch1) {
        const target = modifyMatch1[1];
        const newValue = modifyMatch1[2];
        return parseTargetAndAction(target, 'modify', newValue);
      }

      // å¤‰æ›´ãƒ‘ã‚¿ãƒ¼ãƒ³2: ã€Œã€œ æ—¥ä»˜ æ™‚é–“ã«å¤‰æ›´ã€ã€Œã€œ æ™‚é–“ã«å¤‰æ›´ã€ã€Œã€œ æ—¥ä»˜ã«å¤‰æ›´ã€
      // åŒºåˆ‡ã‚Šæ–‡å­—: ã‚¹ãƒšãƒ¼ã‚¹ã€ã€Œã¯ã€ã€Œã‚’ã€ã€Œã€ã€
      const modifyEndMatch = input.match(/[ã«ã¸](å¤‰æ›´|å¤‰ãˆã¦|ç§»å‹•|ã—ã¦|ä¿®æ­£|ç›´ã—ã¦|è¨‚æ­£)$/);
      if (modifyEndMatch) {
        const beforeEnd = input.slice(0, modifyEndMatch.index).trim();

        // åŒºåˆ‡ã‚Šæ–‡å­—ãƒ‘ã‚¿ãƒ¼ãƒ³: ã‚¹ãƒšãƒ¼ã‚¹ã€ã¯ã€ã‚’ã€ã€
        const sep = '[\\sã€€ã¯ã‚’ã€]+';

        // ãƒ‘ã‚¿ãƒ¼ãƒ³1: æ—¥ä»˜+æ™‚é–“ï¼ˆä¾‹: 2/15 18æ™‚ã€2/15 1800ï¼‰
        const dateTimeRegex = new RegExp(`^(.+?)${sep}(\\d{1,2}\\/\\d{1,2}[\\sã€€]+(?:\\d{1,2}æ™‚åŠ?|\\d{3,4}))$`);
        const dateTimeMatch = beforeEnd.match(dateTimeRegex);
        if (dateTimeMatch) {
          const targetPart = dateTimeMatch[1].trim();
          const newValuePart = dateTimeMatch[2].trim();
          return parseTargetAndAction(targetPart, 'modify', newValuePart);
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³2: æ™‚é–“ã®ã¿ï¼ˆä¾‹: 18æ™‚ã€1800ï¼‰
        const timeRegex = new RegExp(`^(.+?)${sep}(\\d{1,2}æ™‚åŠ?|\\d{3,4})$`);
        const timeExprMatch = beforeEnd.match(timeRegex);
        if (timeExprMatch) {
          const targetPart = timeExprMatch[1].trim();
          const newValuePart = timeExprMatch[2].trim();
          const hasTime = parseTimeFromText(newValuePart);
          if (hasTime) {
            return parseTargetAndAction(targetPart, 'modify', newValuePart);
          }
        }

        // ãƒ‘ã‚¿ãƒ¼ãƒ³3: æ—¥ä»˜ã®ã¿ï¼ˆä¾‹: 2/15ï¼‰
        const dateRegex = new RegExp(`^(.+?)${sep}(\\d{1,2}\\/\\d{1,2})$`);
        const dateExprMatch = beforeEnd.match(dateRegex);
        if (dateExprMatch) {
          const targetPart = dateExprMatch[1].trim();
          const newValuePart = dateExprMatch[2].trim();
          const hasDate = parseDateFromText(newValuePart);
          if (hasDate) {
            return parseTargetAndAction(targetPart, 'modify', newValuePart);
          }
        }
      }

      // å‰Šé™¤ãƒ‘ã‚¿ãƒ¼ãƒ³: æœ«å°¾ã«å‰Šé™¤ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒã‚ã‚‹å ´åˆ
      const deleteKeywords = /(ã‚’?å‰Šé™¤|ã‚’?æ¶ˆã—ã¦|ã‚’?æ¶ˆã™|ãªããªã£ãŸ|ç„¡ããªã£ãŸ|ã‚­ãƒ£ãƒ³ã‚»ãƒ«|å–ã‚Š?æ¶ˆã—|ä¸­æ­¢|ã‚„ã‚(ãŸ|ã‚‹)?|é–“é•ã„(ã ã£ãŸ)?)$/;
      const deleteMatch = input.match(deleteKeywords);
      if (deleteMatch) {
        const target = input.replace(deleteKeywords, '').trim();
        return parseTargetAndAction(target, 'delete', null);
      }

      return null;
    }

    function parseTargetAndAction(targetStr, action, newValueStr) {
      // å¯¾è±¡ã‹ã‚‰æ—¥ä»˜ãƒ»æ™‚é–“ãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡º
      let targetDate = null;
      let targetTime = null;
      let keyword = targetStr;

      const dateResult = parseDateFromText(targetStr);
      if (dateResult) {
        targetDate = `${dateResult.date.getMonth() + 1}/${dateResult.date.getDate()}`;
        keyword = targetStr.replace(dateResult.consumed, '').trim();
      }

      // æ™‚é–“ã‚‚ãƒ‘ãƒ¼ã‚¹
      const timeResult = parseTimeFromText(keyword);
      if (timeResult) {
        targetTime = formatTime(timeResult.time);
        keyword = keyword.replace(timeResult.consumed, '').trim();
      }

      // ã€Œã®äºˆå®šã€ã€Œã®ã€ãªã©ã‚’é™¤å»
      keyword = keyword.replace(/ã®?äºˆå®š$/, '').replace(/^ã®/, '').trim();

      // å®Œå…¨ä¸€è‡´ã‚’å„ªå…ˆã—ã¦æ¤œç´¢
      let target = null;

      // 1. æ—¥ä»˜ãƒ»æ™‚é–“ãƒ»ã‚¿ã‚¤ãƒˆãƒ«å…¨ã¦æŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã€å®Œå…¨ä¸€è‡´ã‚’æ¢ã™
      if (targetDate && targetTime && keyword) {
        const exactMatch = schedules.find(s =>
          s.date === targetDate && s.time === targetTime && s.title === keyword
        );
        if (exactMatch) {
          target = exactMatch;
        }
      }

      // 2. å®Œå…¨ä¸€è‡´ãŒãªã‘ã‚Œã°éƒ¨åˆ†ä¸€è‡´ã§æ¤œç´¢
      if (!target) {
        const matches = findSchedule(targetDate, targetTime, keyword);

        if (matches.length === 0) {
          return { error: 'è©²å½“ã™ã‚‹äºˆå®šãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚' };
        }
        if (matches.length > 1) {
          return { error: `è¤‡æ•°ã®äºˆå®šãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ã‚‚ã†å°‘ã—å…·ä½“çš„ã«æŒ‡å®šã—ã¦ãã ã•ã„ã€‚\n${matches.map(s => `ãƒ»${s.date} ${s.time || ''} ${s.title}`).join('\n')}` };
        }
        target = matches[0];
      }

      if (action === 'delete') {
        return {
          type: 'delete',
          target
        };
      }

      // å¤‰æ›´ã®å ´åˆã€æ–°ã—ã„å€¤ã‚’ãƒ‘ãƒ¼ã‚¹
      if (action === 'modify') {
        let newDate = target.date;
        let newTime = target.time;
        let newFullDate = target.fullDate;

        const newDateResult = parseDateFromText(newValueStr);
        if (newDateResult) {
          newDate = `${newDateResult.date.getMonth() + 1}/${newDateResult.date.getDate()}`;
          newFullDate = newDateResult.date.toISOString();
        }

        const newTimeResult = parseTimeFromText(newValueStr);
        if (newTimeResult) {
          newTime = formatTime(newTimeResult.time);
        }

        return {
          type: 'modify',
          target,
          newSchedule: {
            ...target,
            date: newDate,
            time: newTime,
            fullDate: newFullDate
          }
        };
      }

      return null;
    }

    // ============================================
    // UIé–¢æ•°
    // ============================================
    function addMessage(type, text, buttonType = null) {
      const div = document.createElement('div');
      div.className = `message ${type}`;
      div.innerHTML = text;

      if (buttonType === 'confirm') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-ok" onclick="handleConfirm()">OK</button>
          <button class="btn-cancel" onclick="handleCancel()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        `;
        div.appendChild(btns);
      } else if (buttonType === 'duplicate') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-skip" onclick="handleDuplicateSkip()">åŒã˜äºˆå®šï¼ˆè¿½åŠ ã—ãªã„ï¼‰</button>
          <button class="btn-add" onclick="handleDuplicateAdd()">åˆ¥ã®äºˆå®šï¼ˆè¿½åŠ ã™ã‚‹ï¼‰</button>
        `;
        div.appendChild(btns);
      } else if (buttonType === 'warning') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-add" onclick="handleWarningAdd()">è¿½åŠ ã™ã‚‹</button>
          <button class="btn-cancel" onclick="handleWarningCancel()">ã‚„ã‚ã‚‹</button>
        `;
        div.appendChild(btns);
      } else if (buttonType === 'modify-warning') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.innerHTML = `
          <button class="btn-add" onclick="handleModifyWarningConfirm()">å¤‰æ›´ã™ã‚‹</button>
          <button class="btn-cancel" onclick="handleModifyWarningCancel()">ã‚„ã‚ã‚‹</button>
        `;
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'conflict-choice') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.style.flexWrap = 'wrap';
        buttonType.choices.forEach((choice, idx) => {
          const btn = document.createElement('button');
          btn.className = 'btn-add';
          btn.textContent = choice;
          btn.onclick = () => handleConflictChoice(idx);
          btns.appendChild(btn);
        });
        const bothBtn = document.createElement('button');
        bothBtn.className = 'btn-skip';
        bothBtn.textContent = 'ä¸¡æ–¹æ®‹ã™';
        bothBtn.onclick = () => handleConflictChoice(-1);
        btns.appendChild(bothBtn);
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'exact-duplicate') {
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        const mergeBtn = document.createElement('button');
        mergeBtn.className = 'btn-add';
        mergeBtn.textContent = '1ä»¶ã«ã¾ã¨ã‚ã‚‹';
        mergeBtn.onclick = () => handleConflictChoice(0);
        btns.appendChild(mergeBtn);
        const keepBtn = document.createElement('button');
        keepBtn.className = 'btn-skip';
        keepBtn.textContent = `${buttonType.count}ä»¶ã¨ã‚‚æ®‹ã™`;
        keepBtn.onclick = () => handleConflictChoice(-1);
        btns.appendChild(keepBtn);
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'double-booking-select') {
        // ç¬¬1æ®µéš: ã©ã®äºˆå®šã‚’ä¿®æ­£ã™ã‚‹ã‹é¸æŠ
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.style.flexWrap = 'wrap';
        buttonType.schedules.forEach((s, idx) => {
          const btn = document.createElement('button');
          btn.className = 'btn-add';
          btn.textContent = s.title;
          btn.onclick = () => handleDoubleBookingSelect(idx);
          btns.appendChild(btn);
        });
        const keepBtn = document.createElement('button');
        keepBtn.className = 'btn-skip';
        keepBtn.textContent = 'ã“ã®ã¾ã¾';
        keepBtn.onclick = () => handleDoubleBookingSelect(-1);
        btns.appendChild(keepBtn);
        div.appendChild(btns);
      } else if (buttonType && buttonType.type === 'double-booking-action') {
        // ç¬¬2æ®µéš: é¸æŠã—ãŸäºˆå®šã‚’ã©ã†ã™ã‚‹ã‹
        const btns = document.createElement('div');
        btns.className = 'confirm-buttons';
        btns.style.flexWrap = 'wrap';
        const otherBtn = document.createElement('button');
        otherBtn.className = 'btn-add';
        otherBtn.textContent = 'ä»–äººã®äºˆå®šã«ã™ã‚‹';
        otherBtn.onclick = () => handleDoubleBookingAction('other');
        btns.appendChild(otherBtn);
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-delete';
        deleteBtn.textContent = 'å‰Šé™¤ã™ã‚‹';
        deleteBtn.onclick = () => handleDoubleBookingAction('delete');
        btns.appendChild(deleteBtn);
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn-skip';
        cancelBtn.textContent = 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«';
        cancelBtn.onclick = () => handleDoubleBookingAction('cancel');
        btns.appendChild(cancelBtn);
        div.appendChild(btns);
      }

      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆisOtherã‚‚æ¡ä»¶ã«å«ã‚ã‚‹ï¼šè‡ªåˆ†ã®äºˆå®šã¨ä»–äººã®äºˆå®šã¯åˆ¥æ‰±ã„ï¼‰
    function isDuplicate(schedule, exclude = null) {
      return schedules.some(s =>
        s !== exclude &&
        s.date === schedule.date &&
        s.time === schedule.time &&
        s.title === schedule.title &&
        !!s.isOther === !!schedule.isOther
      );
    }

    // æœ‰åŠ¹ãªæ™‚é–“ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆ4æ¡ã®æ•°å­—ï¼‰
    function isValidTime(time) {
      return time && time !== 'æœªå®š' && /^\d{4}$/.test(time);
    }

    // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆ2æ™‚é–“ä»¥å†…ã®äºˆå®šã‚’æ¤œå‡ºã€excludeã§æŒ‡å®šã—ãŸäºˆå®šã¯é™¤å¤–ï¼‰
    function findNearbySchedule(schedule, exclude = null) {
      if (!isValidTime(schedule.time) || schedule.isOther) return null;

      const newTime = parseInt(schedule.time.slice(0, 2)) * 60 + parseInt(schedule.time.slice(2));

      for (const s of schedules) {
        // é™¤å¤–æŒ‡å®šã•ã‚ŒãŸäºˆå®šã¯ã‚¹ã‚­ãƒƒãƒ—
        if (s === exclude) continue;
        // åŒã˜æ—¥ã€æœ‰åŠ¹ãªæ™‚é–“ã‚ã‚Šã€è‡ªåˆ†ã®äºˆå®šï¼ˆisOther: falseï¼‰ã®ã¿
        if (s.date === schedule.date && isValidTime(s.time) && !s.isOther) {
          const existingTime = parseInt(s.time.slice(0, 2)) * 60 + parseInt(s.time.slice(2));
          const diff = Math.abs(newTime - existingTime);
          if (diff > 0 && diff <= 120) { // 2æ™‚é–“ä»¥å†…ï¼ˆåŒä¸€æ™‚åˆ»ã¯é™¤ãï¼‰
            return s;
          }
        }
      }
      return null;
    }

    // åŒã˜æ—¥æ™‚ã«æ—¢å­˜ã®è‡ªåˆ†ã®äºˆå®šãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´æ™‚ç”¨ï¼‰
    function findSameTimeSchedules(schedule, exclude = null) {
      if (!isValidTime(schedule.time)) return [];

      return schedules.filter(s =>
        s !== exclude &&
        !s.isOther &&
        s.date === schedule.date &&
        s.time === schedule.time
      );
    }

    // åŒã˜æ—¥æ™‚ã«è‡ªåˆ†ã®äºˆå®šãŒè¤‡æ•°ã‚ã‚‹å ´åˆã‚’æ¤œå‡ºï¼ˆèµ·å‹•æ™‚ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
    function findDoubleBookings() {
      const groups = {};
      schedules.forEach(s => {
        if (!s.isOther && isValidTime(s.time)) {
          const key = `${s.date}_${s.time}`;
          if (!groups[key]) groups[key] = [];
          groups[key].push(s);
        }
      });

      // 2ä»¶ä»¥ä¸Šã‚ã‚‹æ—¥æ™‚ã‚’è¿”ã™
      const conflicts = [];
      Object.keys(groups).forEach(key => {
        if (groups[key].length >= 2) {
          conflicts.push({
            date: groups[key][0].date,
            time: groups[key][0].time,
            schedules: groups[key]
          });
        }
      });
      return conflicts;
    }

    // ä¸€æ‹¬å…¥åŠ›æ™‚ã®åŒä¸€æ—¥æ™‚ã®äºˆå®šã‚’æ¤œå‡ºï¼ˆå®Œå…¨é‡è¤‡ã¨ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ä¸¡æ–¹ï¼‰
    function findSameTimeConflicts(schedulesArray) {
      const groups = {};
      schedulesArray.forEach((s, idx) => {
        if (isValidTime(s.time) && !s.isOther) {
          const key = `${s.date}_${s.time}`;
          if (!groups[key]) groups[key] = [];
          groups[key].push({ schedule: s, index: idx });
        }
      });

      const conflicts = [];
      Object.entries(groups).forEach(([key, items]) => {
        if (items.length <= 1) return;

        // åŒã˜ã‚¿ã‚¤ãƒˆãƒ«ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¤œå‡ºï¼ˆå®Œå…¨é‡è¤‡ï¼‰
        const titleGroups = {};
        items.forEach(item => {
          const title = item.schedule.title;
          if (!titleGroups[title]) titleGroups[title] = [];
          titleGroups[title].push(item);
        });

        // å®Œå…¨é‡è¤‡ï¼ˆåŒã˜ã‚¿ã‚¤ãƒˆãƒ«ãŒ2ä»¶ä»¥ä¸Šï¼‰
        Object.entries(titleGroups).forEach(([title, titleItems]) => {
          if (titleItems.length > 1) {
            conflicts.push({
              key,
              items: titleItems,
              type: 'exact-duplicate',
              title
            });
          }
        });

        // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ï¼ˆç•°ãªã‚‹ã‚¿ã‚¤ãƒˆãƒ«ãŒåŒã˜æ—¥æ™‚ï¼‰
        const uniqueTitles = Object.keys(titleGroups);
        if (uniqueTitles.length > 1) {
          // å„ã‚¿ã‚¤ãƒˆãƒ«ã‹ã‚‰1ä»¶ãšã¤å–å¾—
          const representativeItems = uniqueTitles.map(title => titleGroups[title][0]);
          conflicts.push({
            key,
            items: representativeItems,
            type: 'double-booking'
          });
        }
      });

      return conflicts;
    }

    function formatScheduleDisplay(s) {
      const timeStr = s.time ? ` ${s.time}` : '';
      if (s.isOther) {
        return `(${s.date}${timeStr} ${s.title})`;
      }
      return `${s.date}${timeStr} ${s.title}`;
    }

    // ã‚½ãƒ¼ãƒˆç”¨ã®æ™‚é–“å€¤ã‚’å–å¾—ï¼ˆæœªå®šã¯æœ€å¾Œã«ï¼‰
    function getSortableTime(time) {
      if (!time || time === 'æœªå®š') return '9999';
      return time;
    }

    function formatScheduleList() {
      if (schedules.length === 0) {
        return 'äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“';
      }

      const sorted = [...schedules].sort((a, b) => {
        const dateA = new Date(a.fullDate);
        const dateB = new Date(b.fullDate);
        if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
        return getSortableTime(a.time) > getSortableTime(b.time) ? 1 : -1;
      });

      const grouped = {};
      sorted.forEach(s => {
        if (!grouped[s.date]) grouped[s.date] = [];
        grouped[s.date].push(s);
      });

      // å›ºå®šå¹…ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼ˆæ—¥ä»˜5æ–‡å­— + ã‚¹ãƒšãƒ¼ã‚¹1æ–‡å­— = 6æ–‡å­—åˆ†ï¼‰
      const INDENT = '      ';  // åŠè§’ã‚¹ãƒšãƒ¼ã‚¹6ã¤

      let lines = ['äºˆå®šï¼'];
      Object.keys(grouped).forEach(date => {
        // æ—¥ä»˜ã‚’å›ºå®šå¹…ï¼ˆ5æ–‡å­—ï¼‰ã«ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
        const paddedDate = date.padEnd(5, ' ');
        grouped[date].forEach((s, idx) => {
          const timeStr = s.time ? `${s.time} ` : '';
          let line;
          if (s.isOther) {
            const content = `(${timeStr}${s.title})`;
            if (idx === 0) {
              line = `<span class="other-schedule">${paddedDate} ${content}</span>`;
            } else {
              line = `<span class="other-schedule">${INDENT}${content}</span>`;
            }
          } else {
            const content = `${timeStr}${s.title}`;
            if (idx === 0) {
              line = `${paddedDate} ${content}`;
            } else {
              line = `${INDENT}${content}`;
            }
          }
          lines.push(line);
        });
      });

      return lines.join('<br>');
    }

    function showScheduleList() {
      const text = formatScheduleList();
      addMessage('system', `<div class="schedule-text">${text}</div>`);
    }

    function setInputEnabled(enabled) {
      inputField.disabled = !enabled;
      document.querySelector('.input-form button').disabled = !enabled;
    }

    // ============================================
    // ç¢ºèªå‡¦ç†
    // ============================================
    function handleConfirm() {
      if (!pendingAction) return;

      if (pendingAction.type === 'add') {
        schedules.push(pendingAction.schedule);
      } else if (pendingAction.type === 'add-multiple') {
        schedules.push(...pendingAction.schedules);
      } else if (pendingAction.type === 'delete') {
        schedules = schedules.filter(s => s !== pendingAction.target);
      } else if (pendingAction.type === 'modify') {
        // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
        if (isDuplicate(pendingAction.newSchedule, pendingAction.target)) {
          addMessage('system', 'ã“ã®æ™‚é–“ã«æ—¢ã«åŒã˜äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚');
          pendingAction = null;
          setInputEnabled(true);
          return;
        }

        // åŒã˜æ—¥æ™‚ã«æ—¢å­˜ã®äºˆå®šãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
        const sameTimeSchedules = findSameTimeSchedules(pendingAction.newSchedule, pendingAction.target);
        if (sameTimeSchedules.length > 0) {
          const titles = sameTimeSchedules.map(s => s.title).join('ã€');
          const confirmText = `${formatScheduleDisplay(pendingAction.target)} â†’ ${formatScheduleDisplay(pendingAction.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ<br><span style="color:#e74c3c">âš  ${pendingAction.newSchedule.date} ${pendingAction.newSchedule.time} ã«æ—¢ã«äºˆå®šãŒã‚ã‚Šã¾ã™ï¼ˆ${titles}ï¼‰</span>`;
          addMessage('confirm', confirmText, 'modify-warning');
          return;
        }

        // 2æ™‚é–“ä»¥å†…ã®äºˆå®šãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
        const nearby = findNearbySchedule(pendingAction.newSchedule, pendingAction.target);
        if (nearby) {
          const confirmText = `${formatScheduleDisplay(pendingAction.target)} â†’ ${formatScheduleDisplay(pendingAction.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ<br><span style="color:#e74c3c">âš  ${formatScheduleDisplay(nearby)} ã®2æ™‚é–“ä»¥å†…ã«äºˆå®šãŒã‚ã‚Šã¾ã™</span>`;
          addMessage('confirm', confirmText, 'modify-warning');
          return;
        }

        const idx = schedules.indexOf(pendingAction.target);
        if (idx !== -1) {
          schedules[idx] = pendingAction.newSchedule;
        }
      }

      localStorage.setItem('schedules', JSON.stringify(schedules));
      showScheduleList();
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleCancel() {
      addMessage('system', 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleDuplicateSkip() {
      addMessage('system', 'è¿½åŠ ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleDuplicateAdd() {
      if (pendingAction && pendingAction.schedule) {
        schedules.push(pendingAction.schedule);
        localStorage.setItem('schedules', JSON.stringify(schedules));
        showScheduleList();
      }
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleWarningAdd() {
      if (pendingAction && pendingAction.schedule) {
        schedules.push(pendingAction.schedule);
        localStorage.setItem('schedules', JSON.stringify(schedules));
        showScheduleList();
      }
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleWarningCancel() {
      addMessage('system', 'è¿½åŠ ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleModifyWarningConfirm() {
      if (pendingAction && pendingAction.target && pendingAction.newSchedule) {
        const idx = schedules.indexOf(pendingAction.target);
        if (idx !== -1) {
          schedules[idx] = pendingAction.newSchedule;
        }
        localStorage.setItem('schedules', JSON.stringify(schedules));
        showScheduleList();
      }
      pendingAction = null;
      setInputEnabled(true);
    }

    function handleModifyWarningCancel() {
      addMessage('system', 'å¤‰æ›´ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
      pendingAction = null;
      setInputEnabled(true);
    }

    // ç¬¬1æ®µéš: ã©ã®äºˆå®šã‚’ä¿®æ­£ã™ã‚‹ã‹é¸æŠ
    function handleDoubleBookingSelect(idx) {
      if (!pendingAction || pendingAction.type !== 'resolve-double-booking') return;

      if (idx >= 0) {
        // é¸æŠã•ã‚ŒãŸäºˆå®šã‚’pendingActionã«ä¿å­˜ã—ã¦ç¬¬2æ®µéšã¸
        pendingAction.selectedSchedule = pendingAction.currentConflict.schedules[idx];
        pendingAction.selectedIndex = idx;
        showDoubleBookingActions();
      } else {
        // ã€Œã“ã®ã¾ã¾ã€ã‚’é¸æŠã—ãŸå ´åˆã¯æ¬¡ã®ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ã¸
        moveToNextDoubleBooking();
      }
    }

    // ç¬¬2æ®µéš: é¸æŠã—ãŸäºˆå®šã‚’ã©ã†ã™ã‚‹ã‹è¡¨ç¤º
    function showDoubleBookingActions() {
      const schedule = pendingAction.selectedSchedule;
      const confirmText = `ã€Œ${schedule.title}ã€ã‚’ã©ã†ã—ã¾ã™ã‹ï¼Ÿ`;
      addMessage('confirm', confirmText, { type: 'double-booking-action' });
    }

    // ç¬¬2æ®µéš: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    function handleDoubleBookingAction(action) {
      if (!pendingAction || pendingAction.type !== 'resolve-double-booking') return;

      const targetSchedule = pendingAction.selectedSchedule;
      const scheduleIdx = schedules.indexOf(targetSchedule);

      if (action === 'other') {
        // ä»–äººã®äºˆå®šã«å¤‰æ›
        if (scheduleIdx !== -1) {
          schedules[scheduleIdx].isOther = true;
          localStorage.setItem('schedules', JSON.stringify(schedules));
          addMessage('system', `ã€Œ${targetSchedule.title}ã€ã‚’ä»–äººã®äºˆå®šã«å¤‰æ›´ã—ã¾ã—ãŸã€‚`);
        }
        moveToNextDoubleBooking();
      } else if (action === 'delete') {
        // å‰Šé™¤
        if (scheduleIdx !== -1) {
          schedules.splice(scheduleIdx, 1);
          localStorage.setItem('schedules', JSON.stringify(schedules));
          addMessage('system', `ã€Œ${targetSchedule.title}ã€ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
        }
        moveToNextDoubleBooking();
      } else if (action === 'cancel') {
        // ã‚­ãƒ£ãƒ³ã‚»ãƒ« - ç¬¬1æ®µéšã«æˆ»ã‚‹
        showNextDoubleBooking();
      }
    }

    // æ¬¡ã®ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ã¸ç§»å‹•
    function moveToNextDoubleBooking() {
      pendingAction.conflictIndex++;
      if (pendingAction.conflictIndex < pendingAction.conflicts.length) {
        showNextDoubleBooking();
      } else {
        pendingAction = null;
        setInputEnabled(true);
        showScheduleList();
      }
    }

    function showNextDoubleBooking() {
      const conflict = pendingAction.conflicts[pendingAction.conflictIndex];
      pendingAction.currentConflict = conflict;
      const confirmText = `${conflict.date} ${conflict.time} ã«äºˆå®šãŒé‡ãªã£ã¦ã„ã¾ã™ã€‚ã©ã®äºˆå®šã‚’ä¿®æ­£ã—ã¾ã™ã‹ï¼Ÿ`;
      addMessage('confirm', confirmText, { type: 'double-booking-select', schedules: conflict.schedules });
    }

    function handleConflictChoice(choiceIdx) {
      if (!pendingAction || pendingAction.type !== 'resolve-conflict') return;

      const conflict = pendingAction.currentConflict;
      if (choiceIdx === -1) {
        // ä¸¡æ–¹æ®‹ã™ - ä½•ã‚‚ã—ãªã„
      } else {
        // é¸æŠã•ã‚ŒãŸã‚‚ã®ä»¥å¤–ã‚’é™¤å¤–
        const keepIndex = conflict.items[choiceIdx].index;
        conflict.items.forEach(item => {
          if (item.index !== keepIndex) {
            pendingAction.schedulesToRemove.add(item.index);
          }
        });
      }

      // æ¬¡ã®è¡çªã‚’ãƒã‚§ãƒƒã‚¯
      processNextConflict();
    }

    function processNextConflict() {
      const { allSchedules, conflicts, schedulesToRemove } = pendingAction;

      if (conflicts.length === 0) {
        // å…¨ã¦ã®è¡çªã‚’è§£æ±º â†’ æœ€çµ‚ç¢ºèª
        const finalSchedules = allSchedules.filter((_, idx) => !schedulesToRemove.has(idx));

        if (finalSchedules.length === 0) {
          addMessage('system', 'è¿½åŠ ã™ã‚‹äºˆå®šãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
          pendingAction = null;
          setInputEnabled(true);
          return;
        }

        const listText = finalSchedules.map(s => formatScheduleDisplay(s)).join('<br>');
        const confirmText = `${finalSchedules.length}ä»¶ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ<br>${listText}`;
        addMessage('confirm', confirmText, 'confirm');
        pendingAction = { type: 'add-multiple', schedules: finalSchedules };
        return;
      }

      // æ¬¡ã®è¡çªã‚’å‡¦ç†
      const nextConflict = conflicts.shift();
      // æ—¢ã«é™¤å¤–ã•ã‚ŒãŸã‚‚ã®ã‚’é™¤ã
      nextConflict.items = nextConflict.items.filter(item => !schedulesToRemove.has(item.index));

      if (nextConflict.items.length <= 1) {
        // è¡çªãŒè§£æ¶ˆã•ã‚ŒãŸ
        processNextConflict();
        return;
      }

      pendingAction.currentConflict = nextConflict;

      const [date, time] = nextConflict.key.split('_');

      if (nextConflict.type === 'exact-duplicate') {
        // å®Œå…¨é‡è¤‡
        const confirmText = `${date} ${time} ã«åŒã˜äºˆå®šãŒ${nextConflict.items.length}ä»¶ã‚ã‚Šã¾ã™ï¼š${nextConflict.title}`;
        addMessage('confirm', confirmText, { type: 'exact-duplicate', count: nextConflict.items.length });
      } else {
        // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°
        const choices = nextConflict.items.map(item => item.schedule.title);
        const confirmText = `${date} ${time} ã«${nextConflict.items.length}ä»¶ã®äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚ã©ã¡ã‚‰ã‚’æ®‹ã—ã¾ã™ã‹ï¼Ÿ`;
        addMessage('confirm', confirmText, { type: 'conflict-choice', choices });
      }
    }

    // ============================================
    // ãƒ•ã‚©ãƒ¼ãƒ é€ä¿¡
    // ============================================
    inputForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const input = inputField.value.trim();
      if (!input) return;

      addMessage('user', input);
      inputField.value = '';

      // äºˆå®šç¢ºèªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆå³å¯†åˆ¤å®šï¼‰
      // æ•°å­—ãŒå«ã¾ã‚Œã¦ã„ãŸã‚‰æ–°è¦è¿½åŠ ã¨ã—ã¦å‡¦ç†
      const scheduleCheckPatterns = ['äºˆå®š', 'äºˆå®šç¢ºèª', 'ä¸€è¦§', 'ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«', 'ä»Šã©ã†ãªã£ã¦ã‚‹', 'ä»Šã©ã†ãªã£ã¦ã‚‹ï¼Ÿ'];
      const normalizedInput = input.trim().replace(/[ï¼Ÿ?ï¼!]/g, '');
      const isScheduleCheck = scheduleCheckPatterns.includes(normalizedInput) ||
        (scheduleCheckPatterns.some(p => normalizedInput === p) && !/\d/.test(input));
      if (isScheduleCheck) {
        showScheduleList();
        return;
      }

      // ã¾ãšå¤‰æ›´ãƒ»å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‹ãƒã‚§ãƒƒã‚¯
      const modRequest = parseModificationRequest(input);
      if (modRequest) {
        if (modRequest.error) {
          addMessage('system', modRequest.error);
          return;
        }

        if (modRequest.type === 'delete') {
          const confirmText = `${formatScheduleDisplay(modRequest.target)} ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`;
          addMessage('confirm', confirmText, 'confirm');
          pendingAction = modRequest;
          setInputEnabled(false);
          return;
        }

        if (modRequest.type === 'modify') {
          // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
          if (isDuplicate(modRequest.newSchedule, modRequest.target)) {
            addMessage('system', 'ã“ã®æ™‚é–“ã«æ—¢ã«åŒã˜äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚');
            return;
          }

          // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆå¤‰æ›´å¯¾è±¡è‡ªèº«ã¯é™¤å¤–ï¼‰
          const nearby = findNearbySchedule(modRequest.newSchedule, modRequest.target);
          if (nearby) {
            const confirmText = `${formatScheduleDisplay(modRequest.target)} â†’ ${formatScheduleDisplay(modRequest.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ<br><span style="color:#e74c3c">âš  ${formatScheduleDisplay(nearby)} ã®2æ™‚é–“ä»¥å†…ã«äºˆå®šãŒã‚ã‚Šã¾ã™</span>`;
            addMessage('confirm', confirmText, 'modify-warning');
            pendingAction = modRequest;
            setInputEnabled(false);
            return;
          }

          const confirmText = `${formatScheduleDisplay(modRequest.target)} â†’ ${formatScheduleDisplay(modRequest.newSchedule)} ã«å¤‰æ›´ã—ã¾ã™ã‹ï¼Ÿ`;
          addMessage('confirm', confirmText, 'confirm');
          pendingAction = modRequest;
          setInputEnabled(false);
          return;
        }
      }

      // æ–°è¦è¿½åŠ 
      const isOther = input.startsWith('(') || input.startsWith('ï¼ˆ');
      // å…ˆé ­ãŒé–‹ãã‚«ãƒƒã‚³ã§å§‹ã¾ã‚‹å ´åˆã®ã¿ã€ä¸¡ç«¯ã®ã‚«ãƒƒã‚³ã‚’å‰Šé™¤
      const cleanInput = isOther ? input.replace(/^[ï¼ˆ(]/, '').replace(/[)ï¼‰]$/, '') : input;

      // è¤‡æ•°äºˆå®šã‹ãƒã‚§ãƒƒã‚¯
      const multipleResult = parseMultipleSchedules(cleanInput);
      if (multipleResult) {
        const multipleSchedules = multipleResult.schedules;
        const skippedSchedules = multipleResult.skipped;

        // ã‚¹ã‚­ãƒƒãƒ—ã•ã‚ŒãŸäºˆå®šãŒã‚ã‚‹å ´åˆã¯è­¦å‘Šã‚’è¡¨ç¤º
        if (skippedSchedules.length > 0) {
          const skippedText = skippedSchedules.join('<br>');
          addMessage('system', `âš  ãƒ‘ãƒ¼ã‚¹ã§ããªã‹ã£ãŸéƒ¨åˆ†ãŒã‚ã‚Šã¾ã™ï¼š<br>${skippedText}`);
        }

        // æ—¢ã«isOther: trueãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹äºˆå®šã¯ä¸Šæ›¸ãã—ãªã„
        multipleSchedules.forEach(s => s.isOther = s.isOther || isOther);
        const originalCount = multipleSchedules.length;

        // æ—¢å­˜äºˆå®šã¨ã®é‡è¤‡ã®ã¿è‡ªå‹•é™¤å¤–ï¼ˆå…¥åŠ›å†…ã®é‡è¤‡ã¯é¸æŠå¼ã§ç¢ºèªï¼‰
        const uniqueSchedules = [];
        let existingDupCount = 0;
        for (const s of multipleSchedules) {
          const isDupInExisting = isDuplicate(s);
          if (!isDupInExisting) {
            uniqueSchedules.push(s);
          } else {
            existingDupCount++;
          }
        }

        if (uniqueSchedules.length === 0) {
          addMessage('system', `${originalCount}ä»¶å…¨ã¦æ—¢ã«ç™»éŒ²æ¸ˆã¿ã§ã™ã€‚`);
          return;
        }

        // æ—¢å­˜äºˆå®šã¨ã®é‡è¤‡é™¤å¤–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        if (existingDupCount > 0) {
          addMessage('system', `${existingDupCount}ä»¶ã¯æ—¢ã«ç™»éŒ²æ¸ˆã¿ã®ãŸã‚é™¤å¤–ã—ã¾ã—ãŸã€‚`);
        }

        // å®Œå…¨é‡è¤‡ã¨ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆåŒä¸€æ—¥æ™‚ã®äºˆå®šï¼‰
        const conflicts = findSameTimeConflicts(uniqueSchedules);

        if (conflicts.length > 0) {
          // è¡çªè§£æ±ºãƒ¢ãƒ¼ãƒ‰ã¸
          pendingAction = {
            type: 'resolve-conflict',
            allSchedules: uniqueSchedules,
            conflicts: conflicts,
            schedulesToRemove: new Set(),
            currentConflict: null
          };
          setInputEnabled(false);
          processNextConflict();
          return;
        }

        // è¡çªãªã— â†’ æœ€çµ‚ç¢ºèª
        const listText = uniqueSchedules.map(s => formatScheduleDisplay(s)).join('<br>');
        const confirmText = `${uniqueSchedules.length}ä»¶ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ<br>${listText}`;
        addMessage('confirm', confirmText, 'confirm');
        pendingAction = { type: 'add-multiple', schedules: uniqueSchedules };
        setInputEnabled(false);
        return;
      }

      // å˜ä¸€äºˆå®š
      const parsed = parseScheduleInput(cleanInput);
      if (parsed) {
        // parseScheduleInputã§ã€Œä»–äººã®äºˆå®šã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã€ã¾ãŸã¯ã‚«ãƒƒã‚³ã§å›²ã¾ã‚Œã¦ã„ãŸå ´åˆ
        parsed.isOther = parsed.isOther || isOther;

        // é‡è¤‡ãƒã‚§ãƒƒã‚¯
        if (isDuplicate(parsed)) {
          const confirmText = `${formatScheduleDisplay(parsed)} ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™ã€‚`;
          addMessage('confirm', confirmText, 'duplicate');
          pendingAction = { type: 'duplicate', schedule: parsed };
          setInputEnabled(false);
        } else {
          // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆè‡ªåˆ†ã®äºˆå®šã®ã¿ï¼‰
          const nearby = findNearbySchedule(parsed);
          if (nearby) {
            const confirmText = `${formatScheduleDisplay(nearby)} ã®2æ™‚é–“ä»¥å†…ã«äºˆå®šãŒã‚ã‚Šã¾ã™ã€‚è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`;
            addMessage('confirm', confirmText, 'warning');
            pendingAction = { type: 'warning', schedule: parsed };
            setInputEnabled(false);
          } else {
            const confirmText = `${formatScheduleDisplay(parsed)} ã‚’è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ`;
            addMessage('confirm', confirmText, 'confirm');
            pendingAction = { type: 'add', schedule: parsed };
            setInputEnabled(false);
          }
        }
      } else {
        addMessage('system', 'æ—¥ä»˜ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã€Œæ¥é€±ã®é‡‘æ›œæ—¥ã€ã€Œæ˜æ—¥ã€ã€Œ1/15ã€ã€Œä»Šæœˆæœ«ã€ãªã©ã‚’å«ã‚ã¦ãã ã•ã„ã€‚');
      }
    });

    // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—é–¢æ•°
    function openPopup(id) {
      document.getElementById(id).style.display = 'flex';
    }

    function closePopup(id) {
      document.getElementById(id).style.display = 'none';
    }

    // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
    document.querySelectorAll('.popup-overlay').forEach(overlay => {
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.style.display = 'none';
        }
      });
    });

    // ãƒ˜ãƒƒãƒ€ãƒ¼ãƒœã‚¿ãƒ³
    document.getElementById('helpBtn').addEventListener('click', () => openPopup('helpPopup'));
    document.getElementById('settingsBtn').addEventListener('click', () => openPopup('settingsPopup'));

    // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    document.getElementById('exportBtn').addEventListener('click', () => {
      if (schedules.length === 0) {
        alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹äºˆå®šãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        return;
      }
      const now = new Date();
      const dateStr = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
      const data = JSON.stringify(schedules, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `yurusuke_backup_${dateStr}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      closePopup('settingsPopup');
      addMessage('system', 'äºˆå®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚');
    });

    // ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    const importFile = document.getElementById('importFile');
    document.getElementById('importBtn').addEventListener('click', () => {
      importFile.click();
    });

    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const importedData = JSON.parse(event.target.result);
          if (!Array.isArray(importedData)) {
            alert('ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚');
            return;
          }

          // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
          const choice = confirm('æ—¢å­˜ã®äºˆå®šã«è¿½åŠ ã—ã¾ã™ã‹ï¼Ÿ\n\nOK: è¿½åŠ ã™ã‚‹\nã‚­ãƒ£ãƒ³ã‚»ãƒ«: ä¸Šæ›¸ãã™ã‚‹');

          if (choice) {
            // è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ï¼šé‡è¤‡ã‚’é™¤ã„ã¦è¿½åŠ 
            let addedCount = 0;
            importedData.forEach(newSchedule => {
              const isDup = schedules.some(s =>
                s.date === newSchedule.date &&
                s.time === newSchedule.time &&
                s.title === newSchedule.title
              );
              if (!isDup) {
                schedules.push(newSchedule);
                addedCount++;
              }
            });
            localStorage.setItem('schedules', JSON.stringify(schedules));
            closePopup('settingsPopup');
            addMessage('system', `${addedCount}ä»¶ã®äºˆå®šã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚`);
          } else {
            // ä¸Šæ›¸ããƒ¢ãƒ¼ãƒ‰
            if (confirm('æ—¢å­˜ã®äºˆå®šã¯å…¨ã¦å‰Šé™¤ã•ã‚Œã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) {
              schedules = importedData;
              localStorage.setItem('schedules', JSON.stringify(schedules));
              closePopup('settingsPopup');
              addMessage('system', `${importedData.length}ä»¶ã®äºˆå®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸã€‚`);
            }
          }
        } catch (err) {
          alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
      };
      reader.readAsText(file);
      // ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠã‚’ãƒªã‚»ãƒƒãƒˆ
      importFile.value = '';
    });

    // å…¨ã¦å‰Šé™¤ãƒœã‚¿ãƒ³ï¼ˆ2æ®µéšç¢ºèªï¼‰
    document.getElementById('deleteAllBtn').addEventListener('click', () => {
      if (schedules.length === 0) {
        alert('å‰Šé™¤ã™ã‚‹äºˆå®šãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
        return;
      }
      if (confirm('æœ¬å½“ã«å…¨ã¦ã®äºˆå®šã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
        if (confirm('ã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚æœ¬å½“ã«å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
          schedules = [];
          localStorage.setItem('schedules', JSON.stringify(schedules));
          closePopup('settingsPopup');
          addMessage('system', 'å…¨ã¦ã®äºˆå®šã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚');
        }
      }
    });

    // éŸ³å£°å…¥åŠ›ï¼ˆWeb Speech APIï¼‰
    const voiceBtn = document.getElementById('voiceBtn');
    let recognition = null;

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'ja-JP';
      recognition.continuous = false;
      recognition.interimResults = false;

      recognition.onstart = () => {
        voiceBtn.classList.add('recording');
      };

      recognition.onend = () => {
        voiceBtn.classList.remove('recording');
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        inputField.value = transcript;
        inputField.focus();
      };

      recognition.onerror = (event) => {
        voiceBtn.classList.remove('recording');
        if (event.error !== 'no-speech') {
          addMessage('system', 'éŸ³å£°èªè­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
      };

      voiceBtn.addEventListener('click', () => {
        if (voiceBtn.classList.contains('recording')) {
          recognition.stop();
        } else {
          recognition.start();
        }
      });
    } else {
      // éŸ³å£°èªè­˜éå¯¾å¿œ
      voiceBtn.style.display = 'none';
    }

    // åˆæœŸåŒ–
    function initializeApp() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const todayStr = `${today.getMonth() + 1}/${today.getDate()}`;

      // éå»ã®äºˆå®šã‚’å‰Šé™¤
      const originalCount = schedules.length;
      schedules = schedules.filter(s => {
        const scheduleDate = new Date(s.fullDate);
        const scheduleDateOnly = new Date(scheduleDate.getFullYear(), scheduleDate.getMonth(), scheduleDate.getDate());
        return scheduleDateOnly >= today;
      });

      const removedCount = originalCount - schedules.length;
      if (removedCount > 0) {
        localStorage.setItem('schedules', JSON.stringify(schedules));
      }

      // å½“æ—¥ã®äºˆå®šã‚’å–å¾—
      const todaySchedules = schedules
        .filter(s => s.date === todayStr)
        .sort((a, b) => getSortableTime(a.time) > getSortableTime(b.time) ? 1 : -1);

      // ä»Šå¾Œã®äºˆå®šï¼ˆå½“æ—¥ä»¥é™ï¼‰
      const futureSchedules = schedules
        .filter(s => s.date !== todayStr)
        .sort((a, b) => {
          const dateA = new Date(a.fullDate);
          const dateB = new Date(b.fullDate);
          if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
          return getSortableTime(a.time) > getSortableTime(b.time) ? 1 : -1;
        });

      // æŒ¨æ‹¶ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      let greeting = 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼<br><br>';

      // å›ºå®šå¹…ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼ˆåŠè§’ã‚¹ãƒšãƒ¼ã‚¹6ã¤ï¼‰
      const INDENT = '      ';

      // æœ¬æ—¥ã®äºˆå®š
      if (todaySchedules.length > 0) {
        greeting += 'æœ¬æ—¥ã®äºˆå®šï¼š<br>';
        const paddedTodayStr = todayStr.padEnd(5, ' ');
        todaySchedules.forEach((s, idx) => {
          const timeStr = s.time ? `${s.time} ` : '';
          if (s.isOther) {
            const content = `(${timeStr}${s.title})`;
            if (idx === 0) {
              greeting += `<span class="other-schedule">${paddedTodayStr} ${content}</span><br>`;
            } else {
              greeting += `<span class="other-schedule">${INDENT}${content}</span><br>`;
            }
          } else {
            const content = `${timeStr}${s.title}`;
            if (idx === 0) {
              greeting += `${paddedTodayStr} ${content}<br>`;
            } else {
              greeting += `${INDENT}${content}<br>`;
            }
          }
        });
      } else {
        greeting += 'æœ¬æ—¥ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<br>';
      }

      // ä»Šå¾Œã®äºˆå®š
      if (futureSchedules.length > 0) {
        greeting += '<br>ä»Šå¾Œã®äºˆå®šï¼š<br>';
        const grouped = {};
        futureSchedules.forEach(s => {
          if (!grouped[s.date]) grouped[s.date] = [];
          grouped[s.date].push(s);
        });
        Object.keys(grouped).forEach(date => {
          const paddedDate = date.padEnd(5, ' ');
          grouped[date].forEach((s, idx) => {
            const timeStr = s.time ? `${s.time} ` : '';
            if (s.isOther) {
              const content = `(${timeStr}${s.title})`;
              if (idx === 0) {
                greeting += `<span class="other-schedule">${paddedDate} ${content}</span><br>`;
              } else {
                greeting += `<span class="other-schedule">${INDENT}${content}</span><br>`;
              }
            } else {
              const content = `${timeStr}${s.title}`;
              if (idx === 0) {
                greeting += `${paddedDate} ${content}<br>`;
              } else {
                greeting += `${INDENT}${content}<br>`;
              }
            }
          });
        });
      }

      addMessage('system', `<div class="schedule-text">${greeting}</div>`);

      // ãƒ€ãƒ–ãƒ«ãƒ–ãƒƒã‚­ãƒ³ã‚°ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜æ—¥æ™‚ã«è‡ªåˆ†ã®äºˆå®šãŒè¤‡æ•°ã‚ã‚‹å ´åˆï¼‰
      const doubleBookings = findDoubleBookings();
      if (doubleBookings.length > 0) {
        pendingAction = {
          type: 'resolve-double-booking',
          conflicts: doubleBookings,
          conflictIndex: 0,
          currentConflict: null
        };
        setInputEnabled(false);
        showNextDoubleBooking();
      }
    }

    initializeApp();

    // Service Workerç™»éŒ²
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .catch(err => console.error('SW registration failed:', err));
    }
  </script>
</body>
</html>
